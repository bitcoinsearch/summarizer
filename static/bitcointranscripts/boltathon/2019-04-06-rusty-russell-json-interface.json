{
    "created_at": null,
    "media": "https://www.youtube.com/watch?v=sNB1N7FyMHA",
    "title": "JSON Interface",
    "body": "JSON Interface with c-lightning and Writing Extensions\n\n<https://twitter.com/kanzure/status/1230892247345852416>\n\n# Intro\n\nOk I have `top` running. We have a plan and we\u2019re going to start from zero. We\u2019re going to clone c-lightning, we\u2019re going to compile it, we\u2019re going to set up a test node. I\u2019m assuming Bitcoin is already installed. We\u2019re going to talk a little about configuring it and stuff like that. All this stuff is useful to see somebody else do. It is documented but it is nice to see someone actually go through it. Then we\u2019re basically going to create a little project. We\u2019re going to create two of these nodes, we\u2019re going to get them to talk to each other so we\u2019ve got a play area to play with. We\u2019re going to stumble across a bug and show you what to do when you hit a bug in c-lightning. We\u2019re going to deep dive into that. We\u2019re going to talk a little bit about JSON and stuff like that. That\u2019s the first half. It is all that infrastructure stuff and setting up and how things work. Then we\u2019re going to write our plugin, the world\u2019s stupidest plugin. Once we\u2019ve got as far as we can with the world\u2019s dumbest plugin and we have an idea of how plugins work, we\u2019re going to step up and write a real plugin, deliberately leaving it a bit unfinished so you get an idea of things that you could do with plugins. I would encourage you to ask questions on the way through particularly if I go through something too fast. We\u2019ve got fifty minutes so hopefully we can get through most of this. I\u2019m going to go into my temp directory.\n\n`cd /tmp`\n\n`git clone https://github.com/ElementsProject/lightning.git`\n\nAs a general rule, with c-lightning we do do releases but it is always more fun to run on master. It should be reasonably stable. I tend to run my nodes on master or pretty close to simply because I like the extra testing. If you\u2019re doing development it is nice to be on master. We\u2019ve got Lightning, it\u2019s master version.\n\n`git describe`\n\nWe\u2019re 81 commits past 0.7.0. This is the latest and greatest.\n\n`less doc/INSTALL.md`\n\nIf we look at the docs it has a lot of stuff including install. It basically tells you how to install on Ubuntu. You install all these things. You obviously need Bitcoin. If you\u2019re doing development you might want to install these things too so you probably do want to do that. Obviously this is my development machine so everything is already installed. It will then tell you to configure and make. I would recommend enabling developer.\n\n`./configure \u2014enable-developer`\n\nThat adds a whole heap of dev options which can let you do weird and wonderful things to lightningd. We run our configuration step, that takes a few seconds and then we build.\n\n`make -j7`\n\nThis will build the whole project, it\u2019s not all that big so it shouldn\u2019t take that long. It does have some external dependencies which it will pull in. That is what takes a lot of the time from the very first build. While that is building we\u2019ll talk about how we\u2019re going to do this. By default when you run c-lightning it operates out of your home directory in a .lightning directory. Since we want to run multiple copies we\u2019re going to force it to operate out of temporary directories for the moment so we can run two of them at once. The way c-lightning is designed is there\u2019s a central daemon and a whole heap of subdaemons. This is done for security because each peer gets its own daemon after the initial handshake. Should anything go wrong with a specific peer they can only mess themselves up, they can\u2019t mess up the other peers at least in theory. We get some increased isolation from that model. That\u2019s why when you see c-lightning running you\u2019ll see some subdaemons running. I\u2019ll show you that as well. We\u2019ll also fire off one daemon per client that is connected. They are pretty lightweight so it doesn\u2019t actually make a difference. You can still have thousands of peers without a huge problem. We can see it all building here, it is pretty verbose. Because we\u2019ve enabled development we\u2019ve got a whole heap of debug options sitting in there as well. Maybe I should have used one of my build machines that\u2019s faster than my laptop for this. It won\u2019t actually take too long. While it is doing that we\u2019ll create some infrastructure. As he says that it\u2019s finished.\n\n`make install`\n\nThat will install a\u2026 bin by default. I\u2019ve set up permissions on my machines so that you don\u2019t have to be root to write in there. All those Lightning things are enabled. The first thing we need to do is run bitcoind. bitcoind has a regtest option which is basically a limited test network. That\u2019s great for testing on your local machine.\n\n`bitcoind -regtest &`\n\nWe fire that up and make a couple of directories. Let\u2019s call them l1 and l2 for our daemons and then we run lightningd.\n\n`mkdir /tmp/l1 /tmp/l2`\n\n`lightningd \u2014network=regtest \u2014lightning-dir=/tmp/l1 &`\n\nThat\u2019s lightningd firing up. It is spitting out a whole heap of stuff. It has chosen itself a random secret and a public key and derived a NSA style codename from it. If you are on the developer version the name of your node also gets appended to the version you\u2019re running. If you don\u2019t enable developer and configure you\u2019ll just get a random name. One thing people often do\u2026. It has populated the /tmp/l1 directory at this point. It is having trouble with fee estimation as you can tell. That will happen because regtest doesn\u2019t do fee estimation and nothing is happening.\n\n`ls -l /tmp/l1/`\n\nIf you look in tmp/l1 it has created a store where it holds all the gossip which just has a header at the moment because there is no gossip on the network. The hsm_secret is the secret that you need to keep secret because from that is derived all the stuff that your node signs. That 32 bytes is important to back up and something that you\u2019d expect to see. It creates a pid file that shows that it is running. It creates a database, sqlite3 database which is pretty standard. It has the lightning-rpc socket and this socket is basically how the command line tool talks to lightningd and how any other tool that you write will talk to lightningd. If we look at the tree, I told you before that it is a heap of subdaemons.\n\n`pstree -p $(cat /tmp/l1/lightning-regtest.pid)`\n\nHere you can see lightningd and there\u2019s lightning_connectd. That\u2019s the one that is responsible for when you ask a connection to come out and when somebody connects in. It sorts out the handshake, who they are and figures out what daemon to hand them to. There\u2019s gossipd which is responsible for all the gossip. It controls routing, it controls gossip about chatting about routing to other nodes and things like pings and stuff all go through gossipd. There\u2019s the hsmd which is the hardware security module that controls all the secrets. It does all the signing, all the cryptographic operations that require knowledge of the secret keys. There is a pay. There is one plugin that we ship by default called pay that implements the pay command which is important.\n\nQ - What\u2019s the advantage of using regtest over testnet?\n\nA - Testnet you can\u2019t control. With regtest I can generate a block whenever I need. I can tell bitcoind generate a new block which is great for testing stuff. With testnet other people can create blocks, it can be significantly more difficult to create a block. People can create blocks randomly outside your control, can fork the network, all those sorts of things. When you want that level of control you do regtest and it\u2019s your private testnet. I tend to test on regtest and then I jump onto the live network. Testing on testnet, it can be interesting if you\u2019re trying to do big tests between remote people on different implementations. But for testing one implementation regtest is way easier.\n\nLet\u2019s run lightning-cli now. I\u2019ll just clear out the spam.\n\n`lightning-cli --lightning-dir=/tmp/li getinfo`\n\nI have to tell it what lightning dir to talk to because it will put it in the wrong place by default. This is the information about our node. You can see its ID here, that\u2019s its public key. We have the alias. Each node gets an alias and a color. You can choose those, you can copy other people. There is no security around that at all. The color by default as you can tell is red, green, blue and it is taken from the first three bytes of your ID. We\u2019ve chosen how many peers we have, how many channels which are all zero. The addresses that we advertise to the network, which is currently none. The bindings which is where we\u2019re listening to which is basically ipv4 and ipv6 localhost. The default Lightning port is 9735 which is actually the unicode codepoint for the lightning symbol. That\u2019s the port that we self assign for the Lightning protocol. The version, the block height we\u2019re on, regtest is 333 blocks in, what network we\u2019re on, how many fees we\u2019ve collected. That\u2019s a nice summary of how your node is going. This is going to be really painful to type so let\u2019s create some aliases.\n\n`alias l1=\u2018lightning-cli \u2014lightning-dir=/tmp/l1`\n\n`alias l2=\u2018lightning-cli \u2014lightning-dir=/tmp/l2`\n\nThat\u2019s going to make our life just a little bit easier. We should pimp our node a little bit.\n\n`l1 stop`\n\nWe will stop our node and we will edit the config file. We might as well tell it that we\u2019re going to be in regtest. We will tell it that we want log-level debug. Log-level debug is really spammy but it is good for trying to figure out what is going on. We\u2019ll also tell it to log into a file rather than spamming our console.\n\n```\necho network=regtest >> /tmp/l1/config\necho log-level=debug >> /tmp/l1/config\necho log-file=/tmp/l1/log >> /tmp/l1/config\necho rgb=ff000 >> /tmp/l1/config\n```\nLet\u2019s set the color. Anyone have a suggestion for what color they want? Everyone likes red right? All red, no green, no blue. And an alias? Up to 32 bytes, can be UTF-8. Anyone want to type a suggestion for an alias name? Satoshi, ok. Not very original but you win by being first.\n\n`echo alias=\u2018satoshi\u2019 >> /tmp/l1/config`\n\nThere is a really important option which you should always run when you\u2019re developing against this stuff which is to disable deprecated APIs. Our JSON API changes sometimes and what happens is we give at least one major version 6-12 months before we remove old options so that your users don\u2019t get screwed over when they upgrade. When you\u2019re developing you should always disable all the deprecated APIs to make sure you\u2019re not accidentally using one. By allow-deprecated-apis=false it gets rid of any JSON APIs and other APIs that are now deprecated. You should always put that in your config when you\u2019re doing testing.\n\n`echo allow-deprecated-apis=false >> /tmp/l1/config`\n\nSo let\u2019s restart our node. We no longer need any of these options except to tell it where the configuration directory is. It is much quieter now which is nice.\n\n`lightningd \u2014lightning-dir=/tmp/l1 &`\n\n`l1 getinfo`\n\nWe\u2019ve got our alias as expected and our color. That\u2019s all pretty good. I will note that there are actually some pretty good manual pages.\n\n`man lightningd-config`\n\nIf it is not installed correctly you\u2019ll need to do:\n\n`man -l ~/devel/cvs/lightning/doc/`\n\nThis documents all the options that you can use. I talked about the difference before between addresses and bind addresses. This is something that people get confused over so I want to address it now. When you gossip on the network and tell people about your node you give them the address to connect to. By default lightningd tries to guess what that is. It binds to port 9735 and tries to work out if it is a public IP address or a private IP address, a loopback or anything else. If it looks public it decides to advertise that by default. But you can have weird set ups of proxies and NAT and everything else in which case you need to specify explicitly what addresses you want. There are three ways of doing it. One is to say address = IP address, port or Tor address or something like that. That is the address to bind to but also if it is not obviously wrong, like it\u2019s a loopback address, that\u2019s also the address that you should advertise. There\u2019s also an explicit way of saying \u201cNo bind to this address and advertise this other address.\u201d You can specify bind addresses and advertised addresses separately if they\u2019re completely different. You could say \u201cAnnounce this address but bind to these addresses.\u201d You can have multiple of those. As soon as you specify any of those, it turns off the automatic address. You won\u2019t get it binding to port 9735 at all. You can turn autolisten back on. Sometimes you might want that. You can also set the proxy if you\u2019re using Tor and stuff like that. There\u2019s a whole heap of options in there that you can read at your leisure. Let\u2019s start another peer.\n\n`lightningd \u2014lightning-dir=/tmp/l2 &`\n\nWe\u2019ll watch it fail and it fails because it is by default trying to use the same port. We obviously need a separate port for that. There is an extension. Instead of binding to a IP address you can tell it to bind to a file. That means that you\u2019ll have to be on this machine to even connect to it as a peer which can be really useful. At this point we\u2019ll see a bug.\n\n`lightningd \u2014lightning-dir=/tmp/l2 \u2014addr=/tmp/l2/peer`\n\nWhen something bad happens you\u2019ll see a backtrace like this. These are the things that you usually send on our bugtracker or come to IRC and say \u201cHey Rusty. Look at this pastebin with the bug that we\u2019ve found.\u201d I found this the other day whilst testing. I am going to briefly show you if you\u2019ve got a bug and you want to chase it down, how we do that. If you remember, we built this with developer options so we can add to this. Then you can tell it what daemon to debug.\n\n`lightningd \u2014lightning-dir=/tmp/l2 \u2014addr=/tmp/l2/peer \u2014dev-debugger=connectd`\n\nWhat it will do is by default it runs up its own terminal with gdb in it to attach to that daemon just after it has started up. Because Ubuntu tries to be secure you have to do this.\n\n`echo 0 | sudo dd of=/proc/sys/kernel/yarn\u2026..e_scope`\n\nThis time gdb will mange to connect. So gdb is connected. It failed for a different reason because we didn\u2019t have the port that we told it to use.\n\n`rm /tmp/l2/peer`\n\n`lightningd \u2014lightning-dir=/tmp/l2 \u2014addr=/tmp/l2/peer \u2014dev-debugger=connectd`\n\nHere we can see it aborted. Here is the line where it aborted, line 997. We can poke around and see what\u2019s wrong. That\u2019s supposed to be false and it\u2019s true. As it happens this is because I used an unsupported option and this is a bug that I have a fix pending for but I deliberately didn\u2019t fix it so that we could look at how you would track down this kind of thing. This allows you to open it in debugger, you can do all kinds of things like look around the source files, go up a level and see what\u2019s being called and stuff like that. In this case the workaround is easy. We do bind address. The reason it is asserting is because it is trying to advertise this address but this is a local address. This should never happen. It is a bug. A bind address does what we want.\n\n`rm -f /tmp/l2/peer; lightningd \u2014lightning-dir=/tmp/l2 \u2014bind-addr=/tmp/l2/peer`\n\nIt is upset about bitcoind. The reason that happened is because we didn\u2019t tell it what network to use. It was trying to connect to the testnet network.\n\n`rm -f /tmp/l2/peer; lightningd \u2014lightning-dir=/tmp/l2 \u2014network=regtest \u2014bind-addr=/tmp/l2/peer &`\n\nThere we go, we\u2019ve got a juniorset, that\u2019s our second node.\n\n`l1 getinfo`\n\n We have two nodes now. As you can see l2\u2019s binding address is a local socket there. Now let\u2019s connect them together. We can tell l1 to connect. In order to connect to a node you need to know its keys so you can do a cryptographic handshake. We say connect to that @ the filename which in this case is a local socket rather than an IP address.\n\n`l1 connect 2019-04-07T01:23:19.754Z`\n\nThat\u2019s connected.\n\n`l1 listpeers`\n\nWe can see it is connected to l2 and l2 is connected to l1. If you ask each one it is connected to the other one. So this is pretty low level. This format here is JSON, the Javascript Object Notation. We\u2019re going to get spammed by l2. Let me restart that. Let\u2019s rerun l2 with a log option to kill that.\n\n`rm -f /tmp/l2/peer; lightningd \u2014lightning-dir=/tmp/l2 \u2014network=regtest \u2014bind-addr=/tmp/l2/peer \u2014log-file=/tmp/l2/log &`\n\nNow let\u2019s look at listpeers.\n\n`l2 listpeers`\n\nIt is currently disconnected. Let\u2019s connect again.\n\n`l1 connect 02c3f6c70fa61f5032f9ac5ec28185cf233d62cd99d71fdf364a899d623313e42e@/tmp/l2/peer`\n\n`l1 listpeers`\n\nOk this is JSON. JSON is pretty simple key-value pairs. We have open curlies for objects and we have square brackets for arrays. It is pretty easy to deal with in almost every language. That\u2019s why we use it. The real reason we use it is that bitcoind uses JSON, not because it was a deep choice where we considered all the options. That was what bitcoind did. We\u2019ve fired up our peers and connected. Let\u2019s create our first plugin. I\u2019m going to do something really dumb that you should never do which is create a plugin in shell. That\u2019s just because this is a really cheap demo.\n\n`cat > /tmp/plugin.sh`\n\nWhatever it gets it will put into plugin.log. We need to make it executable.\n\n`chmod a+x /tmp/plugin.sh`\n\nThat\u2019s the world\u2019s stupidest plugin. Now let\u2019s stop l1.\n\n`l1 stop`\n\nYou can either specify a plugin directory and it will look for everything that is executable that looks like a plugin in that directory and fire it off or you can specify a specific plugin which is what we\u2019ll do here.\n\n`lightningd \u2014lightning-dir=/tmp/l1 \u2014plugin=/tmp/plugin.sh`\n\nThe old one has died. Let\u2019s look in /tmp/l1/log.\n\n`cat /tmp/l1/log`\n\nIt hasn\u2019t done anything yet, that\u2019\u2019s strange. Let\u2019s do pstree.\n\n`pstree`\n\nI\u2019ve got a lot of crap. We told it to dump stuff in plugin.log. It has sent this JSON message to our plugin. Our plugin of course is stupid and doesn\u2019t respond. What will in fact happen is that after 60 seconds it will give up on the plugin and refuse to start. Plugins have to respond to `getmanifest` and `getmanifest` is where the plugin says \u201cHere is what I support.\u201d There\u2019s the failure. plugin.sh failed to respond to `getmanifest` in time and something is badly broken. `getmanifest` should be really fast. We know what it is going to send us for `getmanifest` and we can follow our slightly ridiculous example a little further. We can actually respond to `getmanifest`. We\u2019re going to do this and then abandon this really stupid plugin.\n\n`vi /tmp/plugin.sh`\n\nWe need to get the ID. Every JSON RPC command has an ID. We read whatever they send us until we get an ID line and they go \u201cOk that\u2019s great I will respond with that ID.\u201d In response to the stuff that it has asked us we tell it what options we support. In this case `dumboption` and what methods we supply and we call it `dumbmethod`. Anything else it sends we put into the log again. Let\u2019s do `--help`.\n\nHere it lists all the options that lightningd takes and you can see down the bottom it has added `dumboption`. It has queried our plugin and our plugin has gone \u201cYeah we\u2019ve got an option called dumboption.\u201d It gets integrated into the help message. It also adds a new method called `dumbmethod`.\n\n`l1 dumb method`\n\nIt hangs because our plugin is complete crap and doesn\u2019t answer anything.\n\n`cat /tmp/plugin.log`\n\nThere\u2019s the rest of the `getmanifest`. We sent back a joke manifest. Then it said to initialize ourselves and then it has handed us this dumb method and it is waiting for a response which is obviously never going to come. The reason I like introducing plugins at the really low level is if you try to debug something because it is going terribly wrong you will see this JSON flying back and forth. You\u2019ll see it in the logs, you can log it out of your own daemon, stuff like that. You will get exposed at that level, to the JSON that is going past and it is nice to see. If you manage to screw up and produce something you can\u2019t parse you can look at it and see what is going wrong. The other interesting thing here is that when your plugin gets initialized, it goes through and asks all the plugins what they support so it can build up options and then it initializes them all. It tells it what directory you are operating from and where the RPC file is to connect in if the plugin itself wants to make JSON queries to the Lightning daemon. You get those two by default and usually you read those out. At this point it is time to stop playing around and write a real plugin. The standard way to write a real plugin is to take the contrib plugins, hello world plugin and make it your own.\n\n`cp contrib/plugins/helloworld.py /tmp/plugin.py`\n\nIn this case we will call it `plugin.py` and this uses the Python library so you need pylightning installed. You can either `pip3 install pylightning` or you can install it directly like this.\n\n`cd contrib/pylightning && python3 setup.py develop`\n\nThat installs it locally so you\u2019ve got a local version of it running. Now let\u2019s `l1 stop`.\n\n`lightningd \u2014lightning-dir=/tmp/l1 \u2014plugin=/tmp/plugin.py`\n\nThis is the default hello world plugin that will run in the background.\n\n`l1 help`\n\nHere you go. You can see it has got a hello, that\u2019s the hello plugin. It just provides a hello function that echos back what you want. This is important. From a user point of view plugins are part of c-lightning. They have exactly the same power that anything has that is built into c-lightning. In fact that is one of the reasons we\u2019ve moved pay out. Over time we are going to move more stuff out to plugins. In particular we are going to enhance the RPC API so plugins can do more powerful things. That is something that is actively going on now in development which is why it is good to look at master. But it also means that if you are writing a plugin and you want something, it is a really good time to ask us and say \u201cHey I wish I had a plugin that could do this. Could you add a RPC call?\u201d We could discuss what\u2019s the best API because we are going to have to support it for a while. To make plugins more powerful, eventually most of the power of c-lightning is going to move out to plugins.\n\nWe\u2019ve got this little plugin in Python which is probably the easiest way to write a plugin.\n\n`vi /tmp/plugin.py`\n\nBasically `from lightning import Plugin` it starts up a plugin and you have these annotators that say what methods you have. That\u2019s the hello method, that\u2019s the documentation. It gets a greeting option and it basically just prints it straight back. Here\u2019s what happens when it initializes, it doesn\u2019t do anything apart from print out hello world. You can also have subscriptions. Subscriptions are basically things that you tell in your manifest, you say \u201cHey lightningd I want to know when these things happen\u201d and it will call you and notify you. Currently there are connect and disconnect. There are a lot of others coming. It\u2019ll show you what happens when peers connect and you can whatever you want there. We don\u2019t really need those subscriptions, we can delete them. Here\u2019s an option for example `\u2014greeting` defaults to hello and tells you the greeting it should use. You can run `lightningd \u2014greeting`. Anything that you can specify in the command line you can also specify in that config file. Instead of `\u2014greeting` you would just `greeting=config file`. One of the coolest things about Python is you can do this.\n\n```import threading```\n\nWe want to do a web service. We want to provide a web API. I completely cut and pasted this from the really good documentation for Flask.\n\n`app = Flask(_names__)`\n\nFlask is basically a web server inside of Python programs. I turned debugging off.\n\n`app.debug = False`\n\nThen you tell it what to serve. You annotate again.\n\nInside our thread when we get emitted we will start the Flask thread as daemon.\n\n`threading.Thread(target=app.run, daemon=True).start()`\n\nThat turns it into a web server. Remember we made it executable, we copied it from the hello world thing which is already executable. You can run plugins manually. This is actually how they get done by lightningd. For debugging it is really cool to run them manually.\n\nQ - Are the processes for plugins running throughout the lifetime of lightningd or are they invoked in a new process each time there\u2019s an event?\n\nA - The processes for plugins are connected to the lifetime of lightningd. lightningd will start them up and will shut them down, kill them off which is really useful for a whole heap of things. It means lightningd is in control and if they obey the directory you can run up multiple lightningd\u2019s and they should all live happily in their own directories and things. They can have their own configuration file. There are two ways to write a plugin. One is it could have its own config file in a format that it wants. The other way is to just tell lightningd what options it wants and then lightningd will do the parsing for it and hand those options through. It depends how sophisticated your plugin is but certainly I prefer the integrated approach at least to start with for plugins which is what I\u2019ve done here.\n\nQ - Is there anything for community plugins to get rated on trustworthiness?\n\nA - There is actually a Lightning plugins [repo](https://github.com/lightningd/plugins) that contains a few plugins that people have written but we haven\u2019t formally gone through as far as doing community vetting for plugins and stuff. That kind of thing will come with more security later on. As things get more sophisticated there will be more vetting of plugins and things. For the moment, you run a plugin, you\u2019ve got like 3 testnet Bitcoin and someone compromises it. That\u2019s ok. We\u2019re still at the reckless phase of Lightning. Obviously caveat emptor. If you\u2019ve got a serious amount of money on your node you should be reading through the plugins if you\u2019re downloading and running. Because you can specify a plugin directory you can just drop them in a plugin directory and in fact there are options you can specify to blacklist particular plugins and not start those up. You can specify multiple directories. I expect there to be a lot of growth in plugins and I expect people from this call to write plugins and go \u201cI can\u2019t do something because there is not a powerful enough API.\u201d So we will add that pretty much on demand.\n\nLet\u2019s run this up manually. In this case we are lightningd invoking our plugin. We need to hand it that string which was the JSON string about `getmanifest`. We need to ask it to `getmanifest`. Here\u2019s one we printed earlier so we\u2019ll just cut and paste that in. There you go. It gave us the manifest. It is telling us everything about itself. Then we need to tell it to init. We also had one of those because we spat out what we got given before. Here we go. It has actually dumped a log, it is actually using the logging stuff to dump a backtrace because obviously I committed a typo somewhere. That was my fault. That thing I cut and pasted in was not the correct value. I fed it a dumboption here which it didn\u2019t say it was interested in so naturally the plugin freaked out. Let\u2019s try that again. Here\u2019s your `getmanifest` call and here is your options call. I will skip the bit that you wouldn\u2019t want and give you that bit. Now Flask printed out some crap and it says it is running on localhost.\n\n`127.0.0.1:5000`\n\nThere we go. There\u2019s our plugin running a web server inside it. We can debug it that way and tell that it works. There is a trick on the Python plugin stuff if we take out `autopatch=True`. The example does this. You probably shouldn\u2019t do it anymore. There is an environment variable when lightningd runs, it tells it to autopatch, otherwise it doesn\u2019t. That\u2019s why instead of a standard backtrace we got it in log format. The Python plugin infrastructure actually captures everything your plugin writes out and turns it into a log message. That\u2019s not so useful if you are running it manually. Turning off autopatch makes that better. It seems to kind of work. Let\u2019s run l2.\n\n`l1 stop`\n\nIf we run up our plugin now, it should be running.\n\n`lightningd \u2014lightning-dir=/tmp/l1 \u2014plugin=/tmp/plugin.py &`\n\nIt seems to be running too which is good.\n\n`cat /tmp/l1/log`\n\nIf we look into l1 log\u2026 Flask is actually logging to standard output which is getting turned into a log message which comes through here. We can see our GET request. That works pretty nicely for us. Obviously we can control logging levels and stuff like that. We\u2019re doing debugging logging so we\u2019re getting pretty much everything that the plugin prints out at this point. We should probably do something a bit more useful than printing out hello world. What we\u2019re going to do is when they hit that URL we are going to give them an invoice. Instead of that hello world function we are going to do something a bit better. This function here prints hello world. Let\u2019s do something a bit more ambitious. When you create an invoice, people often ask this, there\u2019s this label field that has to be set and has to be unique from the invoice. You have to set that, you are responsible for setting it. The reason that exists is that there is a race condition. If you say to lightningd \u201ccreate this invoice\u201d and something goes wrong you then have to know whether or not the invoice actually got created before it died when the machine caught on fire or not. By forcing that uniqueness constraint it means that if you retry it will say \u201cNo that already exists, you can\u2019t do it.\u201d That is why you have to provide a unique label. It is for robustness. For little things like this we don\u2019t care so we\u2019ve just grabbed 8 bytes of randomness and we\u2019ve thrown that in as the label in hex. Let\u2019s do that. We\u2019ll stop 1 and restart it.\n\n`l1 stop`\n`lightningd \u2014lightning-dir=/tmp/l1 \u2014plugin=/tmp/plugin.py &`\n\nSomething bad went wrong. Let\u2019s look in our log.\n\n`less /tmp/l1/log`\n\nHere we go. We have got the Python backtrace \u201cname secrets is not defined.\u201d Rusty screwed up and didn\u2019t do the `import secrets` line at the top. That wasn\u2019t the bug I expected to hit. Let\u2019s do that again. This is the bug that I expected to hit.\n\n`l1 stop`\n`lightningd \u2014lightning-dir=/tmp/l1 \u2014plugin=/tmp/plugin.py &`\n\nWe run it up again, we hit reload, we get an internal server error and we\u2019ll get a more useful bug report from the logs.\n\n`less /tmp/l1/log`\n\nThis line here is the important one. \u201cTypeError: invoice() missing 1 required positional argument: \u2018description\u2019\u201d. We didn\u2019t provide description to the invoice and you have to do a description. The description gets embedded in the invoice and it describes what you\u2019re offering the person if they pay. The spec says, it is completely unforceable, it is supposed to be descriptive. It should describe what they\u2019re getting. If you\u2019re selling shoes over the internet it should be \u201cShipping shoes to blah, to this address\u201d or \u201cThis many shoes\u201d or whatever it is you are doing. It does have a link limit of 640 characters but that should be enough to provide a comprehensive summary. Let\u2019s fix our plugin. Because the plugin is already running we have to restart every time. Let\u2019s put a description in.\n\n`description= \u201cGet a better description\u201d`\n\nLet\u2019s do the stop and start dance again.\n\n`l1 stop`\n`lightningd \u2014lightning-dir=/tmp/l1 \u2014plugin=/tmp/plugin.py &`\n\nThis time it was supposed to work. Let me check the logs. I did actually fix this and then I rebooted my machine and lost the fix.\n\n`vi /tmp/plugin.py`\n\n`return invoice[\u2018bolt11\u2019]`\n\nThis returns a struct. We just want the BOLT 11 part of the invoice.\n\n`l1 stop`\n`lightningd \u2014lightning-dir=/tmp/l1 \u2014plugin=/tmp/plugin.py &`\n\nThere we go. It has created this massive long invoice. You can tell that it is `lnbcrt`, `bcrt` is the regtest network. Let\u2019s decode that. There\u2019s a cool tool called `bolt11-cli decode`.\n\n`devtools/bolt11-cli decode [add invoice]`\n\nHere we can see what currency, timestamp, when it expires, who it pays to which is our node, payment hash, how long it has got, `min_final_cltv_expiry` is how many blocks you need to have remaining on the payment when it occurs, how much it is for. 24 millisatoshi. This is redundant, we also print it out as msat format. And a description that we put in and finally the signature which proves that this node indeed issued the invoice. That is pretty straightforward. Of course we want to test that we can actually pay it. We\u2019ve only got five minutes to go so I am going to very quickly run through this. Let\u2019s do our connect, we may have already been connected.\n\n`l1 connect 02c3f6c70fa61\u2026/tmp/l2/peer`\n\n Let\u2019s get an address from l2.\n\n`l2 newaddr`\n\nBech32 address, that\u2019s fine. Now you need to do bitcoin-cli.\n\n`bitcoin-cli -regtest sendtoaddress bcrt1qmgk\u2026. 10`\n\nSend ourselves 10 Bitcoin, there we go. We need to mine that. Bitcoin regtest, you can tell it to mine however many blocks. For regtest we do everything with one confirmation because that is enough.\n\n`bitcoin-cli -regtest generatetoaddress 1 \u2018bitcoin-cli -regtest getnewaddress\u2019`\n\nThere we go. We get it to generate something. Now if we do list funds. After l2 has caught up, it calls every 30 seconds or so. It will eventually catch up with blocks.\n\n`l2 listfunds`\n\n`l2 getinfo`\n\nThere we go, cool. We\u2019ve got a confirmed payment, the value in millisatoshi is a crap load because it is 10 Bitcoin. Now l2 has funds. l2 needs to fund the channel.\n\n`l2 fundchannel 02e20e8b7058\u2026. 0.042btc`\n\nBecause this is on regtest it can\u2019t estimate fees so we need to give it a fee rate.\n\n`l2 fundchannel 02e20e8b7058\u2026. 0.042btc 253perkw`\n\nThat was a minimum fee. Then we need to generate another block in order to get that mined. So we generate another block in bitcoind.\n\n`bitcoin-cli -regtest generatetoaddress 1 \u2018bitcoin-cli -regtest getnewaddress\u2019`\n\n`l2 listpeers`\n\nIt has got more information than you\u2019d ever want to know. The `listpeers` has a channel and it is awaiting lockin. It is polling bitcoind every 60 seconds to say \u201cHey has anything come through?\u201d There we go, funding is locked. Now we should be able to pay that invoice.\n\n`l2 pay lnbcrt240p1pw2j\u2026.`\n\nThere we go. It is complete.\n\n`l1 listinvoices`\n\nWe see our invoice. You can see an earlier one that I made in testing. This invoice is paid, the amount, description, everything we want to know about it. What I wanted to do with this was something more interesting. We are pretty much on our time limit. So instead of showing you I will upload this. I\u2019ll tweet out the URL. I actually extended it to rather than just producing an invoice for 24 millisatoshis, it actually embedded in the payment preimage 24 bytes of text directly paying for 24 bytes of text. The way payments work is the invoice promises them to give them a secret if they pay. That secret is normally a random number. In this case I used 8 bytes of randomness and the other 24 bytes, it is a 32 byte secret, I actually put a text field in there. This is a cute way of rather than having to separately deliver something you can deliver it as part of the invoice flow. Now 32 bytes is enough to hold a secret key for example. It could be that you give them a file and when they pay they will get the decryption key. The decryption key will be the preimage, that secret that you promised them. In this case I used 8 bytes of randomness to make it harder to guess and then 24 bytes of some text. That could be done for some kind of pay to reveal text kind of thing. In fact I wrote a plugin to do that for you, to do the URL query so it added a getword, you just did `blah l2 getword`. The plugin itself then reached out to the URL that you gave it, fetched the invoice, checked it was a sane amount and paid it. I can upload those plugins somewhere if people want. I think we\u2019ve hit time. Did anyone want to ask any specific questions before we wrap up?\n\n# Q&A\n\nQ - What languages are supported to write plugins in? Shell scripts or Python?\n\nA - Do not write them in shell, no. Python is good. The pay plugin is written in C. There\u2019s a lib plugin for C. There is also some Go. niftynei has written some Go infrastructure so you can write it in Go. I didn\u2019t do that because I\u2019m not a Go person, I\u2019m more comfortable with Python. But anything that can understand JSON you can write so any language would work.\n\nQ - C\\#?\n\nA - If somebody wants to go and do C\\#. The problem is that c-lightning itself runs on UNIX based systems only so we don\u2019t have any Windows support so C\\# is not exactly top of our list.\n\nQ - It is possible to do something like HODL invoices in c-lightning using the plugin infrastructure today?\n\nA - Yes. This was always something that we wanted to do. For those not familiar, HODL invoices are what Lightning Labs call them but basically it is adjusting time delivery system. You send out all these invoices and when they come to pay it you go \u201cDo I actually have the thing they are paying for or do I reject at this point?\u201d For some models that is much better than reserving when you send out the invoice. Even though the invoices have an expiry you may well want to send out a whole heap of invoices expecting only a small number of them to come back. You don\u2019t want to hold stock based on the invoices but actual payment. It can be bad UX because of course they get an invoice, they go to pay it and you go \u201cSorry no that didn\u2019t work.\u201d We have a thing in plugins which I didn\u2019t show here called hooks. A hook is like a notification except the whole thing is waiting on the plugin getting back to you to say \u201cYes it\u2019s good\u201d or \u201cNo it\u2019s not good.\u201d Subscriptions are for notifications where you get told stuff is happening but hooks are actually blocking. A hook on payment receipt is really important for this. You\u2019d write a plugin that registers with that hook and when it actually comes in it goes \u201cShould I actually honor this payment now?\u201d Yes it matches the invoice but maybe there is some other reason that I don\u2019t want to. That would allow you to HODL invoices. Maybe you\u2019d just hold off for a while until something else is lined up. For a complex system that is actually quite important. You may have a whole CMS system around it.\n\nQ - .NET Core run on Linux?\n\nA - Yes. .NET Core can definitely run on Linux. You could do C\\# on Linux. It is just a question of it wasn\u2019t the most popular language for people to use on Linux. That is why there\u2019s no C\\# plugin. It would be pretty easy to write. If you can speak JSON you handle those bits, you handle the registration for them and it is pretty easy. It is pretty easy to write in any language natively but it is nice if you\u2019ve got a library that does all that infrastructure for you and registers your options and does all that stuff rather than having to do it manually.\n\nQ - Thank you so much Rusty. This was fantastic. If people want to reach out to you and ask you more questions where they can find you?\n\nA - \\@rusty_twit on Twitter is usually the best way of doing it. We also hang out on both the \\#lightning-dev and \\#c-lightning IRC channels on Freenode. \\#lightning-dev is generally for general Lightning development discussion and protocol discussion and \\#c-lightning is specifically for c-lightning questions. Of course my email is pretty easy to Google as well. rusty at blockstream.com or rusty at rustcorp.com.au.",
    "url": "https://btctranscripts.com/boltathon/2019-04-06-rusty-russell-json-interface",
    "tags": [
        "lightning",
        "c-lightning"
    ],
    "body_formatted": "JSON Interface with c-lightning and Writing Extensions\n\n<https://twitter.com/kanzure/status/1230892247345852416>\n\n# Intro\n\nOk I have `top` running. We have a plan and we\u2019re going to start from zero. We\u2019re going to clone c-lightning, we\u2019re going to compile it, we\u2019re going to set up a test node. I\u2019m assuming Bitcoin is already installed. We\u2019re going to talk a little about configuring it and stuff like that. All this stuff is useful to see somebody else do. It is documented but it is nice to see someone actually go through it. Then we\u2019re basically going to create a little project. We\u2019re going to create two of these nodes, we\u2019re going to get them to talk to each other so we\u2019ve got a play area to play with. We\u2019re going to stumble across a bug and show you what to do when you hit a bug in c-lightning. We\u2019re going to deep dive into that. We\u2019re going to talk a little bit about JSON and stuff like that. That\u2019s the first half. It is all that infrastructure stuff and setting up and how things work. Then we\u2019re going to write our plugin, the world\u2019s stupidest plugin. Once we\u2019ve got as far as we can with the world\u2019s dumbest plugin and we have an idea of how plugins work, we\u2019re going to step up and write a real plugin, deliberately leaving it a bit unfinished so you get an idea of things that you could do with plugins. I would encourage you to ask questions on the way through particularly if I go through something too fast. We\u2019ve got fifty minutes so hopefully we can get through most of this. I\u2019m going to go into my temp directory.\n\n`cd /tmp`\n\n`git clone https://github.com/ElementsProject/lightning.git`\n\nAs a general rule, with c-lightning we do do releases but it is always more fun to run on master. It should be reasonably stable. I tend to run my nodes on master or pretty close to simply because I like the extra testing. If you\u2019re doing development it is nice to be on master. We\u2019ve got Lightning, it\u2019s master version.\n\n`git describe`\n\nWe\u2019re 81 commits past 0.7.0. This is the latest and greatest.\n\n`less doc/INSTALL.md`\n\nIf we look at the docs it has a lot of stuff including install. It basically tells you how to install on Ubuntu. You install all these things. You obviously need Bitcoin. If you\u2019re doing development you might want to install these things too so you probably do want to do that. Obviously this is my development machine so everything is already installed. It will then tell you to configure and make. I would recommend enabling developer.\n\n`./configure \u2014enable-developer`\n\nThat adds a whole heap of dev options which can let you do weird and wonderful things to lightningd. We run our configuration step, that takes a few seconds and then we build.\n\n`make -j7`\n\nThis will build the whole project, it\u2019s not all that big so it shouldn\u2019t take that long. It does have some external dependencies which it will pull in. That is what takes a lot of the time from the very first build. While that is building we\u2019ll talk about how we\u2019re going to do this. By default when you run c-lightning it operates out of your home directory in a .lightning directory. Since we want to run multiple copies we\u2019re going to force it to operate out of temporary directories for the moment so we can run two of them at once. The way c-lightning is designed is there\u2019s a central daemon and a whole heap of subdaemons. This is done for security because each peer gets its own daemon after the initial handshake. Should anything go wrong with a specific peer they can only mess themselves up, they can\u2019t mess up the other peers at least in theory. We get some increased isolation from that model. That\u2019s why when you see c-lightning running you\u2019ll see some subdaemons running. I\u2019ll show you that as well. We\u2019ll also fire off one daemon per client that is connected. They are pretty lightweight so it doesn\u2019t actually make a difference. You can still have thousands of peers without a huge problem. We can see it all building here, it is pretty verbose. Because we\u2019ve enabled development we\u2019ve got a whole heap of debug options sitting in there as well. Maybe I should have used one of my build machines that\u2019s faster than my laptop for this. It won\u2019t actually take too long. While it is doing that we\u2019ll create some infrastructure. As he says that it\u2019s finished.\n\n`make install`\n\nThat will install a\u2026 bin by default. I\u2019ve set up permissions on my machines so that you don\u2019t have to be root to write in there. All those Lightning things are enabled. The first thing we need to do is run bitcoind. bitcoind has a regtest option which is basically a limited test network. That\u2019s great for testing on your local machine.\n\n`bitcoind -regtest &`\n\nWe fire that up and make a couple of directories. Let\u2019s call them l1 and l2 for our daemons and then we run lightningd.\n\n`mkdir /tmp/l1 /tmp/l2`\n\n`lightningd \u2014network=regtest \u2014lightning-dir=/tmp/l1 &`\n\nThat\u2019s lightningd firing up. It is spitting out a whole heap of stuff. It has chosen itself a random secret and a public key and derived a NSA style codename from it. If you are on the developer version the name of your node also gets appended to the version you\u2019re running. If you don\u2019t enable developer and configure you\u2019ll just get a random name. One thing people often do\u2026. It has populated the /tmp/l1 directory at this point. It is having trouble with fee estimation as you can tell. That will happen because regtest doesn\u2019t do fee estimation and nothing is happening.\n\n`ls -l /tmp/l1/`\n\nIf you look in tmp/l1 it has created a store where it holds all the gossip which just has a header at the moment because there is no gossip on the network. The hsm_secret is the secret that you need to keep secret because from that is derived all the stuff that your node signs. That 32 bytes is important to back up and something that you\u2019d expect to see. It creates a pid file that shows that it is running. It creates a database, sqlite3 database which is pretty standard. It has the lightning-rpc socket and this socket is basically how the command line tool talks to lightningd and how any other tool that you write will talk to lightningd. If we look at the tree, I told you before that it is a heap of subdaemons.\n\n`pstree -p $(cat /tmp/l1/lightning-regtest.pid)`\n\nHere you can see lightningd and there\u2019s lightning_connectd. That\u2019s the one that is responsible for when you ask a connection to come out and when somebody connects in. It sorts out the handshake, who they are and figures out what daemon to hand them to. There\u2019s gossipd which is responsible for all the gossip. It controls routing, it controls gossip about chatting about routing to other nodes and things like pings and stuff all go through gossipd. There\u2019s the hsmd which is the hardware security module that controls all the secrets. It does all the signing, all the cryptographic operations that require knowledge of the secret keys. There is a pay. There is one plugin that we ship by default called pay that implements the pay command which is important.\n\nQ - What\u2019s the advantage of using regtest over testnet?\n\nA - Testnet you can\u2019t control. With regtest I can generate a block whenever I need. I can tell bitcoind generate a new block which is great for testing stuff. With testnet other people can create blocks, it can be significantly more difficult to create a block. People can create blocks randomly outside your control, can fork the network, all those sorts of things. When you want that level of control you do regtest and it\u2019s your private testnet. I tend to test on regtest and then I jump onto the live network. Testing on testnet, it can be interesting if you\u2019re trying to do big tests between remote people on different implementations. But for testing one implementation regtest is way easier.\n\nLet\u2019s run lightning-cli now. I\u2019ll just clear out the spam.\n\n`lightning-cli --lightning-dir=/tmp/li getinfo`\n\nI have to tell it what lightning dir to talk to because it will put it in the wrong place by default. This is the information about our node. You can see its ID here, that\u2019s its public key. We have the alias. Each node gets an alias and a color. You can choose those, you can copy other people. There is no security around that at all. The color by default as you can tell is red, green, blue and it is taken from the first three bytes of your ID. We\u2019ve chosen how many peers we have, how many channels which are all zero. The addresses that we advertise to the network, which is currently none. The bindings which is where we\u2019re listening to which is basically ipv4 and ipv6 localhost. The default Lightning port is 9735 which is actually the unicode codepoint for the lightning symbol. That\u2019s the port that we self assign for the Lightning protocol. The version, the block height we\u2019re on, regtest is 333 blocks in, what network we\u2019re on, how many fees we\u2019ve collected. That\u2019s a nice summary of how your node is going. This is going to be really painful to type so let\u2019s create some aliases.\n\n`alias l1=\u2018lightning-cli \u2014lightning-dir=/tmp/l1`\n\n`alias l2=\u2018lightning-cli \u2014lightning-dir=/tmp/l2`\n\nThat\u2019s going to make our life just a little bit easier. We should pimp our node a little bit.\n\n`l1 stop`\n\nWe will stop our node and we will edit the config file. We might as well tell it that we\u2019re going to be in regtest. We will tell it that we want log-level debug. Log-level debug is really spammy but it is good for trying to figure out what is going on. We\u2019ll also tell it to log into a file rather than spamming our console.\n\n```\necho network=regtest >> /tmp/l1/config\necho log-level=debug >> /tmp/l1/config\necho log-file=/tmp/l1/log >> /tmp/l1/config\necho rgb=ff000 >> /tmp/l1/config\n```\nLet\u2019s set the color. Anyone have a suggestion for what color they want? Everyone likes red right? All red, no green, no blue. And an alias? Up to 32 bytes, can be UTF-8. Anyone want to type a suggestion for an alias name? Satoshi, ok. Not very original but you win by being first.\n\n`echo alias=\u2018satoshi\u2019 >> /tmp/l1/config`\n\nThere is a really important option which you should always run when you\u2019re developing against this stuff which is to disable deprecated APIs. Our JSON API changes sometimes and what happens is we give at least one major version 6-12 months before we remove old options so that your users don\u2019t get screwed over when they upgrade. When you\u2019re developing you should always disable all the deprecated APIs to make sure you\u2019re not accidentally using one. By allow-deprecated-apis=false it gets rid of any JSON APIs and other APIs that are now deprecated. You should always put that in your config when you\u2019re doing testing.\n\n`echo allow-deprecated-apis=false >> /tmp/l1/config`\n\nSo let\u2019s restart our node. We no longer need any of these options except to tell it where the configuration directory is. It is much quieter now which is nice.\n\n`lightningd \u2014lightning-dir=/tmp/l1 &`\n\n`l1 getinfo`\n\nWe\u2019ve got our alias as expected and our color. That\u2019s all pretty good. I will note that there are actually some pretty good manual pages.\n\n`man lightningd-config`\n\nIf it is not installed correctly you\u2019ll need to do:\n\n`man -l ~/devel/cvs/lightning/doc/`\n\nThis documents all the options that you can use. I talked about the difference before between addresses and bind addresses. This is something that people get confused over so I want to address it now. When you gossip on the network and tell people about your node you give them the address to connect to. By default lightningd tries to guess what that is. It binds to port 9735 and tries to work out if it is a public IP address or a private IP address, a loopback or anything else. If it looks public it decides to advertise that by default. But you can have weird set ups of proxies and NAT and everything else in which case you need to specify explicitly what addresses you want. There are three ways of doing it. One is to say address = IP address, port or Tor address or something like that. That is the address to bind to but also if it is not obviously wrong, like it\u2019s a loopback address, that\u2019s also the address that you should advertise. There\u2019s also an explicit way of saying \u201cNo bind to this address and advertise this other address.\u201d You can specify bind addresses and advertised addresses separately if they\u2019re completely different. You could say \u201cAnnounce this address but bind to these addresses.\u201d You can have multiple of those. As soon as you specify any of those, it turns off the automatic address. You won\u2019t get it binding to port 9735 at all. You can turn autolisten back on. Sometimes you might want that. You can also set the proxy if you\u2019re using Tor and stuff like that. There\u2019s a whole heap of options in there that you can read at your leisure. Let\u2019s start another peer.\n\n`lightningd \u2014lightning-dir=/tmp/l2 &`\n\nWe\u2019ll watch it fail and it fails because it is by default trying to use the same port. We obviously need a separate port for that. There is an extension. Instead of binding to a IP address you can tell it to bind to a file. That means that you\u2019ll have to be on this machine to even connect to it as a peer which can be really useful. At this point we\u2019ll see a bug.\n\n`lightningd \u2014lightning-dir=/tmp/l2 \u2014addr=/tmp/l2/peer`\n\nWhen something bad happens you\u2019ll see a backtrace like this. These are the things that you usually send on our bugtracker or come to IRC and say \u201cHey Rusty. Look at this pastebin with the bug that we\u2019ve found.\u201d I found this the other day whilst testing. I am going to briefly show you if you\u2019ve got a bug and you want to chase it down, how we do that. If you remember, we built this with developer options so we can add to this. Then you can tell it what daemon to debug.\n\n`lightningd \u2014lightning-dir=/tmp/l2 \u2014addr=/tmp/l2/peer \u2014dev-debugger=connectd`\n\nWhat it will do is by default it runs up its own terminal with gdb in it to attach to that daemon just after it has started up. Because Ubuntu tries to be secure you have to do this.\n\n`echo 0 | sudo dd of=/proc/sys/kernel/yarn\u2026..e_scope`\n\nThis time gdb will mange to connect. So gdb is connected. It failed for a different reason because we didn\u2019t have the port that we told it to use.\n\n`rm /tmp/l2/peer`\n\n`lightningd \u2014lightning-dir=/tmp/l2 \u2014addr=/tmp/l2/peer \u2014dev-debugger=connectd`\n\nHere we can see it aborted. Here is the line where it aborted, line 997. We can poke around and see what\u2019s wrong. That\u2019s supposed to be false and it\u2019s true. As it happens this is because I used an unsupported option and this is a bug that I have a fix pending for but I deliberately didn\u2019t fix it so that we could look at how you would track down this kind of thing. This allows you to open it in debugger, you can do all kinds of things like look around the source files, go up a level and see what\u2019s being called and stuff like that. In this case the workaround is easy. We do bind address. The reason it is asserting is because it is trying to advertise this address but this is a local address. This should never happen. It is a bug. A bind address does what we want.\n\n`rm -f /tmp/l2/peer; lightningd \u2014lightning-dir=/tmp/l2 \u2014bind-addr=/tmp/l2/peer`\n\nIt is upset about bitcoind. The reason that happened is because we didn\u2019t tell it what network to use. It was trying to connect to the testnet network.\n\n`rm -f /tmp/l2/peer; lightningd \u2014lightning-dir=/tmp/l2 \u2014network=regtest \u2014bind-addr=/tmp/l2/peer &`\n\nThere we go, we\u2019ve got a juniorset, that\u2019s our second node.\n\n`l1 getinfo`\n\n We have two nodes now. As you can see l2\u2019s binding address is a local socket there. Now let\u2019s connect them together. We can tell l1 to connect. In order to connect to a node you need to know its keys so you can do a cryptographic handshake. We say connect to that @ the filename which in this case is a local socket rather than an IP address.\n\n`l1 connect 2019-04-07T01:23:19.754Z`\n\nThat\u2019s connected.\n\n`l1 listpeers`\n\nWe can see it is connected to l2 and l2 is connected to l1. If you ask each one it is connected to the other one. So this is pretty low level. This format here is JSON, the Javascript Object Notation. We\u2019re going to get spammed by l2. Let me restart that. Let\u2019s rerun l2 with a log option to kill that.\n\n`rm -f /tmp/l2/peer; lightningd \u2014lightning-dir=/tmp/l2 \u2014network=regtest \u2014bind-addr=/tmp/l2/peer \u2014log-file=/tmp/l2/log &`\n\nNow let\u2019s look at listpeers.\n\n`l2 listpeers`\n\nIt is currently disconnected. Let\u2019s connect again.\n\n`l1 connect 02c3f6c70fa61f5032f9ac5ec28185cf233d62cd99d71fdf364a899d623313e42e@/tmp/l2/peer`\n\n`l1 listpeers`\n\nOk this is JSON. JSON is pretty simple key-value pairs. We have open curlies for objects and we have square brackets for arrays. It is pretty easy to deal with in almost every language. That\u2019s why we use it. The real reason we use it is that bitcoind uses JSON, not because it was a deep choice where we considered all the options. That was what bitcoind did. We\u2019ve fired up our peers and connected. Let\u2019s create our first plugin. I\u2019m going to do something really dumb that you should never do which is create a plugin in shell. That\u2019s just because this is a really cheap demo.\n\n`cat > /tmp/plugin.sh`\n\nWhatever it gets it will put into plugin.log. We need to make it executable.\n\n`chmod a+x /tmp/plugin.sh`\n\nThat\u2019s the world\u2019s stupidest plugin. Now let\u2019s stop l1.\n\n`l1 stop`\n\nYou can either specify a plugin directory and it will look for everything that is executable that looks like a plugin in that directory and fire it off or you can specify a specific plugin which is what we\u2019ll do here.\n\n`lightningd \u2014lightning-dir=/tmp/l1 \u2014plugin=/tmp/plugin.sh`\n\nThe old one has died. Let\u2019s look in /tmp/l1/log.\n\n`cat /tmp/l1/log`\n\nIt hasn\u2019t done anything yet, that\u2019\u2019s strange. Let\u2019s do pstree.\n\n`pstree`\n\nI\u2019ve got a lot of crap. We told it to dump stuff in plugin.log. It has sent this JSON message to our plugin. Our plugin of course is stupid and doesn\u2019t respond. What will in fact happen is that after 60 seconds it will give up on the plugin and refuse to start. Plugins have to respond to `getmanifest` and `getmanifest` is where the plugin says \u201cHere is what I support.\u201d There\u2019s the failure. plugin.sh failed to respond to `getmanifest` in time and something is badly broken. `getmanifest` should be really fast. We know what it is going to send us for `getmanifest` and we can follow our slightly ridiculous example a little further. We can actually respond to `getmanifest`. We\u2019re going to do this and then abandon this really stupid plugin.\n\n`vi /tmp/plugin.sh`\n\nWe need to get the ID. Every JSON RPC command has an ID. We read whatever they send us until we get an ID line and they go \u201cOk that\u2019s great I will respond with that ID.\u201d In response to the stuff that it has asked us we tell it what options we support. In this case `dumboption` and what methods we supply and we call it `dumbmethod`. Anything else it sends we put into the log again. Let\u2019s do `--help`.\n\nHere it lists all the options that lightningd takes and you can see down the bottom it has added `dumboption`. It has queried our plugin and our plugin has gone \u201cYeah we\u2019ve got an option called dumboption.\u201d It gets integrated into the help message. It also adds a new method called `dumbmethod`.\n\n`l1 dumb method`\n\nIt hangs because our plugin is complete crap and doesn\u2019t answer anything.\n\n`cat /tmp/plugin.log`\n\nThere\u2019s the rest of the `getmanifest`. We sent back a joke manifest. Then it said to initialize ourselves and then it has handed us this dumb method and it is waiting for a response which is obviously never going to come. The reason I like introducing plugins at the really low level is if you try to debug something because it is going terribly wrong you will see this JSON flying back and forth. You\u2019ll see it in the logs, you can log it out of your own daemon, stuff like that. You will get exposed at that level, to the JSON that is going past and it is nice to see. If you manage to screw up and produce something you can\u2019t parse you can look at it and see what is going wrong. The other interesting thing here is that when your plugin gets initialized, it goes through and asks all the plugins what they support so it can build up options and then it initializes them all. It tells it what directory you are operating from and where the RPC file is to connect in if the plugin itself wants to make JSON queries to the Lightning daemon. You get those two by default and usually you read those out. At this point it is time to stop playing around and write a real plugin. The standard way to write a real plugin is to take the contrib plugins, hello world plugin and make it your own.\n\n`cp contrib/plugins/helloworld.py /tmp/plugin.py`\n\nIn this case we will call it `plugin.py` and this uses the Python library so you need pylightning installed. You can either `pip3 install pylightning` or you can install it directly like this.\n\n`cd contrib/pylightning && python3 setup.py develop`\n\nThat installs it locally so you\u2019ve got a local version of it running. Now let\u2019s `l1 stop`.\n\n`lightningd \u2014lightning-dir=/tmp/l1 \u2014plugin=/tmp/plugin.py`\n\nThis is the default hello world plugin that will run in the background.\n\n`l1 help`\n\nHere you go. You can see it has got a hello, that\u2019s the hello plugin. It just provides a hello function that echos back what you want. This is important. From a user point of view plugins are part of c-lightning. They have exactly the same power that anything has that is built into c-lightning. In fact that is one of the reasons we\u2019ve moved pay out. Over time we are going to move more stuff out to plugins. In particular we are going to enhance the RPC API so plugins can do more powerful things. That is something that is actively going on now in development which is why it is good to look at master. But it also means that if you are writing a plugin and you want something, it is a really good time to ask us and say \u201cHey I wish I had a plugin that could do this. Could you add a RPC call?\u201d We could discuss what\u2019s the best API because we are going to have to support it for a while. To make plugins more powerful, eventually most of the power of c-lightning is going to move out to plugins.\n\nWe\u2019ve got this little plugin in Python which is probably the easiest way to write a plugin.\n\n`vi /tmp/plugin.py`\n\nBasically `from lightning import Plugin` it starts up a plugin and you have these annotators that say what methods you have. That\u2019s the hello method, that\u2019s the documentation. It gets a greeting option and it basically just prints it straight back. Here\u2019s what happens when it initializes, it doesn\u2019t do anything apart from print out hello world. You can also have subscriptions. Subscriptions are basically things that you tell in your manifest, you say \u201cHey lightningd I want to know when these things happen\u201d and it will call you and notify you. Currently there are connect and disconnect. There are a lot of others coming. It\u2019ll show you what happens when peers connect and you can whatever you want there. We don\u2019t really need those subscriptions, we can delete them. Here\u2019s an option for example `\u2014greeting` defaults to hello and tells you the greeting it should use. You can run `lightningd \u2014greeting`. Anything that you can specify in the command line you can also specify in that config file. Instead of `\u2014greeting` you would just `greeting=config file`. One of the coolest things about Python is you can do this.\n\n```import threading```\n\nWe want to do a web service. We want to provide a web API. I completely cut and pasted this from the really good documentation for Flask.\n\n`app = Flask(_names__)`\n\nFlask is basically a web server inside of Python programs. I turned debugging off.\n\n`app.debug = False`\n\nThen you tell it what to serve. You annotate again.\n\nInside our thread when we get emitted we will start the Flask thread as daemon.\n\n`threading.Thread(target=app.run, daemon=True).start()`\n\nThat turns it into a web server. Remember we made it executable, we copied it from the hello world thing which is already executable. You can run plugins manually. This is actually how they get done by lightningd. For debugging it is really cool to run them manually.\n\nQ - Are the processes for plugins running throughout the lifetime of lightningd or are they invoked in a new process each time there\u2019s an event?\n\nA - The processes for plugins are connected to the lifetime of lightningd. lightningd will start them up and will shut them down, kill them off which is really useful for a whole heap of things. It means lightningd is in control and if they obey the directory you can run up multiple lightningd\u2019s and they should all live happily in their own directories and things. They can have their own configuration file. There are two ways to write a plugin. One is it could have its own config file in a format that it wants. The other way is to just tell lightningd what options it wants and then lightningd will do the parsing for it and hand those options through. It depends how sophisticated your plugin is but certainly I prefer the integrated approach at least to start with for plugins which is what I\u2019ve done here.\n\nQ - Is there anything for community plugins to get rated on trustworthiness?\n\nA - There is actually a Lightning plugins [repo](https://github.com/lightningd/plugins) that contains a few plugins that people have written but we haven\u2019t formally gone through as far as doing community vetting for plugins and stuff. That kind of thing will come with more security later on. As things get more sophisticated there will be more vetting of plugins and things. For the moment, you run a plugin, you\u2019ve got like 3 testnet Bitcoin and someone compromises it. That\u2019s ok. We\u2019re still at the reckless phase of Lightning. Obviously caveat emptor. If you\u2019ve got a serious amount of money on your node you should be reading through the plugins if you\u2019re downloading and running. Because you can specify a plugin directory you can just drop them in a plugin directory and in fact there are options you can specify to blacklist particular plugins and not start those up. You can specify multiple directories. I expect there to be a lot of growth in plugins and I expect people from this call to write plugins and go \u201cI can\u2019t do something because there is not a powerful enough API.\u201d So we will add that pretty much on demand.\n\nLet\u2019s run this up manually. In this case we are lightningd invoking our plugin. We need to hand it that string which was the JSON string about `getmanifest`. We need to ask it to `getmanifest`. Here\u2019s one we printed earlier so we\u2019ll just cut and paste that in. There you go. It gave us the manifest. It is telling us everything about itself. Then we need to tell it to init. We also had one of those because we spat out what we got given before. Here we go. It has actually dumped a log, it is actually using the logging stuff to dump a backtrace because obviously I committed a typo somewhere. That was my fault. That thing I cut and pasted in was not the correct value. I fed it a dumboption here which it didn\u2019t say it was interested in so naturally the plugin freaked out. Let\u2019s try that again. Here\u2019s your `getmanifest` call and here is your options call. I will skip the bit that you wouldn\u2019t want and give you that bit. Now Flask printed out some crap and it says it is running on localhost.\n\n`127.0.0.1:5000`\n\nThere we go. There\u2019s our plugin running a web server inside it. We can debug it that way and tell that it works. There is a trick on the Python plugin stuff if we take out `autopatch=True`. The example does this. You probably shouldn\u2019t do it anymore. There is an environment variable when lightningd runs, it tells it to autopatch, otherwise it doesn\u2019t. That\u2019s why instead of a standard backtrace we got it in log format. The Python plugin infrastructure actually captures everything your plugin writes out and turns it into a log message. That\u2019s not so useful if you are running it manually. Turning off autopatch makes that better. It seems to kind of work. Let\u2019s run l2.\n\n`l1 stop`\n\nIf we run up our plugin now, it should be running.\n\n`lightningd \u2014lightning-dir=/tmp/l1 \u2014plugin=/tmp/plugin.py &`\n\nIt seems to be running too which is good.\n\n`cat /tmp/l1/log`\n\nIf we look into l1 log\u2026 Flask is actually logging to standard output which is getting turned into a log message which comes through here. We can see our GET request. That works pretty nicely for us. Obviously we can control logging levels and stuff like that. We\u2019re doing debugging logging so we\u2019re getting pretty much everything that the plugin prints out at this point. We should probably do something a bit more useful than printing out hello world. What we\u2019re going to do is when they hit that URL we are going to give them an invoice. Instead of that hello world function we are going to do something a bit better. This function here prints hello world. Let\u2019s do something a bit more ambitious. When you create an invoice, people often ask this, there\u2019s this label field that has to be set and has to be unique from the invoice. You have to set that, you are responsible for setting it. The reason that exists is that there is a race condition. If you say to lightningd \u201ccreate this invoice\u201d and something goes wrong you then have to know whether or not the invoice actually got created before it died when the machine caught on fire or not. By forcing that uniqueness constraint it means that if you retry it will say \u201cNo that already exists, you can\u2019t do it.\u201d That is why you have to provide a unique label. It is for robustness. For little things like this we don\u2019t care so we\u2019ve just grabbed 8 bytes of randomness and we\u2019ve thrown that in as the label in hex. Let\u2019s do that. We\u2019ll stop 1 and restart it.\n\n`l1 stop`\n`lightningd \u2014lightning-dir=/tmp/l1 \u2014plugin=/tmp/plugin.py &`\n\nSomething bad went wrong. Let\u2019s look in our log.\n\n`less /tmp/l1/log`\n\nHere we go. We have got the Python backtrace \u201cname secrets is not defined.\u201d Rusty screwed up and didn\u2019t do the `import secrets` line at the top. That wasn\u2019t the bug I expected to hit. Let\u2019s do that again. This is the bug that I expected to hit.\n\n`l1 stop`\n`lightningd \u2014lightning-dir=/tmp/l1 \u2014plugin=/tmp/plugin.py &`\n\nWe run it up again, we hit reload, we get an internal server error and we\u2019ll get a more useful bug report from the logs.\n\n`less /tmp/l1/log`\n\nThis line here is the important one. \u201cTypeError: invoice() missing 1 required positional argument: \u2018description\u2019\u201d. We didn\u2019t provide description to the invoice and you have to do a description. The description gets embedded in the invoice and it describes what you\u2019re offering the person if they pay. The spec says, it is completely unforceable, it is supposed to be descriptive. It should describe what they\u2019re getting. If you\u2019re selling shoes over the internet it should be \u201cShipping shoes to blah, to this address\u201d or \u201cThis many shoes\u201d or whatever it is you are doing. It does have a link limit of 640 characters but that should be enough to provide a comprehensive summary. Let\u2019s fix our plugin. Because the plugin is already running we have to restart every time. Let\u2019s put a description in.\n\n`description= \u201cGet a better description\u201d`\n\nLet\u2019s do the stop and start dance again.\n\n`l1 stop`\n`lightningd \u2014lightning-dir=/tmp/l1 \u2014plugin=/tmp/plugin.py &`\n\nThis time it was supposed to work. Let me check the logs. I did actually fix this and then I rebooted my machine and lost the fix.\n\n`vi /tmp/plugin.py`\n\n`return invoice[\u2018bolt11\u2019]`\n\nThis returns a struct. We just want the BOLT 11 part of the invoice.\n\n`l1 stop`\n`lightningd \u2014lightning-dir=/tmp/l1 \u2014plugin=/tmp/plugin.py &`\n\nThere we go. It has created this massive long invoice. You can tell that it is `lnbcrt`, `bcrt` is the regtest network. Let\u2019s decode that. There\u2019s a cool tool called `bolt11-cli decode`.\n\n`devtools/bolt11-cli decode [add invoice]`\n\nHere we can see what currency, timestamp, when it expires, who it pays to which is our node, payment hash, how long it has got, `min_final_cltv_expiry` is how many blocks you need to have remaining on the payment when it occurs, how much it is for. 24 millisatoshi. This is redundant, we also print it out as msat format. And a description that we put in and finally the signature which proves that this node indeed issued the invoice. That is pretty straightforward. Of course we want to test that we can actually pay it. We\u2019ve only got five minutes to go so I am going to very quickly run through this. Let\u2019s do our connect, we may have already been connected.\n\n`l1 connect 02c3f6c70fa61\u2026/tmp/l2/peer`\n\n Let\u2019s get an address from l2.\n\n`l2 newaddr`\n\nBech32 address, that\u2019s fine. Now you need to do bitcoin-cli.\n\n`bitcoin-cli -regtest sendtoaddress bcrt1qmgk\u2026. 10`\n\nSend ourselves 10 Bitcoin, there we go. We need to mine that. Bitcoin regtest, you can tell it to mine however many blocks. For regtest we do everything with one confirmation because that is enough.\n\n`bitcoin-cli -regtest generatetoaddress 1 \u2018bitcoin-cli -regtest getnewaddress\u2019`\n\nThere we go. We get it to generate something. Now if we do list funds. After l2 has caught up, it calls every 30 seconds or so. It will eventually catch up with blocks.\n\n`l2 listfunds`\n\n`l2 getinfo`\n\nThere we go, cool. We\u2019ve got a confirmed payment, the value in millisatoshi is a crap load because it is 10 Bitcoin. Now l2 has funds. l2 needs to fund the channel.\n\n`l2 fundchannel 02e20e8b7058\u2026. 0.042btc`\n\nBecause this is on regtest it can\u2019t estimate fees so we need to give it a fee rate.\n\n`l2 fundchannel 02e20e8b7058\u2026. 0.042btc 253perkw`\n\nThat was a minimum fee. Then we need to generate another block in order to get that mined. So we generate another block in bitcoind.\n\n`bitcoin-cli -regtest generatetoaddress 1 \u2018bitcoin-cli -regtest getnewaddress\u2019`\n\n`l2 listpeers`\n\nIt has got more information than you\u2019d ever want to know. The `listpeers` has a channel and it is awaiting lockin. It is polling bitcoind every 60 seconds to say \u201cHey has anything come through?\u201d There we go, funding is locked. Now we should be able to pay that invoice.\n\n`l2 pay lnbcrt240p1pw2j\u2026.`\n\nThere we go. It is complete.\n\n`l1 listinvoices`\n\nWe see our invoice. You can see an earlier one that I made in testing. This invoice is paid, the amount, description, everything we want to know about it. What I wanted to do with this was something more interesting. We are pretty much on our time limit. So instead of showing you I will upload this. I\u2019ll tweet out the URL. I actually extended it to rather than just producing an invoice for 24 millisatoshis, it actually embedded in the payment preimage 24 bytes of text directly paying for 24 bytes of text. The way payments work is the invoice promises them to give them a secret if they pay. That secret is normally a random number. In this case I used 8 bytes of randomness and the other 24 bytes, it is a 32 byte secret, I actually put a text field in there. This is a cute way of rather than having to separately deliver something you can deliver it as part of the invoice flow. Now 32 bytes is enough to hold a secret key for example. It could be that you give them a file and when they pay they will get the decryption key. The decryption key will be the preimage, that secret that you promised them. In this case I used 8 bytes of randomness to make it harder to guess and then 24 bytes of some text. That could be done for some kind of pay to reveal text kind of thing. In fact I wrote a plugin to do that for you, to do the URL query so it added a getword, you just did `blah l2 getword`. The plugin itself then reached out to the URL that you gave it, fetched the invoice, checked it was a sane amount and paid it. I can upload those plugins somewhere if people want. I think we\u2019ve hit time. Did anyone want to ask any specific questions before we wrap up?\n\n# Q&A\n\nQ - What languages are supported to write plugins in? Shell scripts or Python?\n\nA - Do not write them in shell, no. Python is good. The pay plugin is written in C. There\u2019s a lib plugin for C. There is also some Go. niftynei has written some Go infrastructure so you can write it in Go. I didn\u2019t do that because I\u2019m not a Go person, I\u2019m more comfortable with Python. But anything that can understand JSON you can write so any language would work.\n\nQ - C\\#?\n\nA - If somebody wants to go and do C\\#. The problem is that c-lightning itself runs on UNIX based systems only so we don\u2019t have any Windows support so C\\# is not exactly top of our list.\n\nQ - It is possible to do something like HODL invoices in c-lightning using the plugin infrastructure today?\n\nA - Yes. This was always something that we wanted to do. For those not familiar, HODL invoices are what Lightning Labs call them but basically it is adjusting time delivery system. You send out all these invoices and when they come to pay it you go \u201cDo I actually have the thing they are paying for or do I reject at this point?\u201d For some models that is much better than reserving when you send out the invoice. Even though the invoices have an expiry you may well want to send out a whole heap of invoices expecting only a small number of them to come back. You don\u2019t want to hold stock based on the invoices but actual payment. It can be bad UX because of course they get an invoice, they go to pay it and you go \u201cSorry no that didn\u2019t work.\u201d We have a thing in plugins which I didn\u2019t show here called hooks. A hook is like a notification except the whole thing is waiting on the plugin getting back to you to say \u201cYes it\u2019s good\u201d or \u201cNo it\u2019s not good.\u201d Subscriptions are for notifications where you get told stuff is happening but hooks are actually blocking. A hook on payment receipt is really important for this. You\u2019d write a plugin that registers with that hook and when it actually comes in it goes \u201cShould I actually honor this payment now?\u201d Yes it matches the invoice but maybe there is some other reason that I don\u2019t want to. That would allow you to HODL invoices. Maybe you\u2019d just hold off for a while until something else is lined up. For a complex system that is actually quite important. You may have a whole CMS system around it.\n\nQ - .NET Core run on Linux?\n\nA - Yes. .NET Core can definitely run on Linux. You could do C\\# on Linux. It is just a question of it wasn\u2019t the most popular language for people to use on Linux. That is why there\u2019s no C\\# plugin. It would be pretty easy to write. If you can speak JSON you handle those bits, you handle the registration for them and it is pretty easy. It is pretty easy to write in any language natively but it is nice if you\u2019ve got a library that does all that infrastructure for you and registers your options and does all that stuff rather than having to do it manually.\n\nQ - Thank you so much Rusty. This was fantastic. If people want to reach out to you and ask you more questions where they can find you?\n\nA - \\@rusty_twit on Twitter is usually the best way of doing it. We also hang out on both the \\#lightning-dev and \\#c-lightning IRC channels on Freenode. \\#lightning-dev is generally for general Lightning development discussion and protocol discussion and \\#c-lightning is specifically for c-lightning questions. Of course my email is pretty easy to Google as well. rusty at blockstream.com or rusty at rustcorp.com.au.",
    "needs_review": false,
    "indexed_at": "2024-10-22T10:48:20.367251",
    "transcript_by": "Michael Folkson",
    "domain": "https://btctranscripts.com/",
    "body_type": "markdown",
    "transcript_source": "boltathon",
    "id": "bitcointranscripts+boltathon+2019-04-06-rusty-russell-json-interface",
    "categories": [
        "conference"
    ],
    "authors": [
        "Rusty Russell"
    ],
    "summary": "In an informative and detailed podcast, Rusty Russell, a prominent figure in the development of c-lightning, takes listeners through the comprehensive process of setting up and experimenting with c-lightning nodes. The session begins with the basics: cloning the c-lightning repository from GitHub, compiling the software, and configuring a test node environment on a local machine. Emphasizing the importance of hands-on experience, Russell walks through each step, providing insights into the rationale behind certain decisions, such as running the master version for development purposes due to its stability and the additional testing opportunities it offers.\n\nThe podcast delves into the architectural design of c-lightning, highlighting its security features. For instance, c-lightning employs a central daemon surrounded by multiple subdaemons to manage different peers, enhancing security through isolation. This design ensures that if a peer encounters an issue, it does not compromise the integrity of the entire system.\n\nA significant portion of the discussion is dedicated to troubleshooting and debugging, illustrating what developers can do when they encounter bugs in c-lightning. Russell demonstrates this by intentionally triggering a bug related to address binding and then meticulously guiding the audience through the debugging process using developer options that provide deeper insight into the software's operations.\n\nThe narrative then shifts towards the JSON interface and the creation of plugins for c-lightning. Russell introduces listeners to the simplest form of a plugin, gradually progressing to more complex examples. This segment thoroughly covers how plugins integrate with c-lightning, offering listeners a practical understanding of plugin development, including handling JSON-RPC commands and managing plugin lifecycles in relation to the c-lightning daemon.\n\nRussell further explores advanced plugin capabilities, such as responding to specific events within the c-lightning network (hooks) and executing autonomous actions. This part of the discussion illuminates the potential of plugins to extend the functionality of c-lightning, touching upon real-world applications like HODL invoices, which demonstrate the dynamic nature of plugin infrastructure in accommodating various payment models.\n\nThroughout the podcast, Russell encourages listener engagement by addressing questions directly, fostering an interactive learning environment. He concludes by emphasizing the open-source nature of the c-lightning project and inviting contributions from the community. The session encapsulates the essence of collaborative development in the Lightning Network ecosystem, encouraging innovation and experimentation.\n\nListeners are left with a rich understanding of c-lightning's architecture, the practical aspects of running and debugging nodes, and the endless possibilities offered by plugin development. Rusty Russell's expertise and approachable teaching style make complex concepts accessible, inspiring developers to contribute to the Lightning Network's growth."
}