{
    "id": "bitcointranscripts+advancing-bitcoin+2019+2019-02-07-matt-corallo-rust-lightning",
    "title": "Rust Lightning",
    "body_formatted": "{\"type\":\"paragraph\",\"text\":\"Flexible Lightning in Rust\"}, {\"type\":\"paragraph\",\"text\":\"Slides: <https://docs.google.com/presentation/d/154bMWdcMCFUco4ZXQ3lWfF51U5dad8pQ23rKVkncnns/edit#slide=id.p>\"}, {\"type\":\"paragraph\",\"text\":\"<https://twitter.com/kanzure/status/1144256392490029057>\"}, {\"type\":\"heading\",\"text\":\"Introduction\"}, {\"type\":\"paragraph\",\"text\":\"Thanks for having me. I want to talk a little bit about a project I\u2019ve been working on for about a year called rust-lightning. I started it in December so a year and a few months ago. This is my first presentation on it so I\u2019m excited to finally get to talk about it a little bit.\"}, {\"type\":\"heading\",\"text\":\"Goals\"}, {\"type\":\"paragraph\",\"text\":\"It is yet another Lightning implementation because somehow we needed another one I guess or really not. But about a year and change ago I decided I want to learn Rust. Everyone is super excited about Rust. What is this thing? Maybe there is something here to it. I also wanted to learn a little bit about Lightning. We didn\u2019t have anyone at Chaincode who had worked on any Lightning things. I wanted to get into the meat of it because we were just a Bitcoin Core shop or research lab so it is nice to have people who know all the different pieces. I kind of figured there\u2019s this spec thing here but most of the implementations have been done by working with each other and it would be nice to have something that is done completely clean room just from the spec, just to see how good the spec is, to improve it, to provide feedback and see what kind of misconceptions I can come up with about how Lightning is supposed to work by just reading the spec without reading any of the other implementations. It turns out there were a number of them, the spec is good but it could use a little bit\u2026 Anyway I kind of got started and I started working on this and writing it. It was fun and I learned a lot about Rust and a lot about Lightning. I kind of realized there is this little niche in the Lightning node ecosystem that really isn\u2019t filled at all. That\u2019s to not be a wholesale node and provide people flexibility to integrate Lightning in the way they want. Today you can go take c-lightning and you can run it and it has a great interface and it works. Or you can take lnd and you can run it and you communicate over gRPC. You can take Eclair and even that has a lot of how it interacts with other peers built in and baked in and how it manages keys and all those things. There\u2019s not really a good Lightning implementation that you bring your own key creation and you figure out how you want the UX to work, you figure out how you want the disk storage to work, how exactly you want all the pieces to fit together. That\u2019s the niche I slipped into trying to fill with this project. The key initial supported use cases are first of all existing wallets. We have this big ecosystem of Bitcoin wallets out there, most of them don\u2019t support Lightning because how would they have supported Lightning a year ago? How are they going to go integrate Lightning without starting completely from scratch, getting all of these protocol details correct and doing a tonne of work to make sure they handle every possible edge case in Lightning correctly. So hopefully rust-lightning is just this easy thing that you can take off the shelf, you can integrate it tightly with all of your existing management of UTXO and chain state and everything. It deals with the rest for you. It deals with channel management and peer management and all of those good things. The other use case that I want to support a little bit better is flexibility around how you do, whether it\u2019s a hardware wallet or whether it\u2019s these partially offline nodes and I\u2019ll get into a little bit more of what I mean by that in a minute, but letting people have more high assurance or at least different security models around how they run their Lightning node instead of just I have an online server and I put funds in it and I trust it is not going to get hacked. That is where it has gone and it has made a lot of progress. It is mostly there. There\u2019s some stuff I want to change in terms of getting the last bits of onchain handling implemented and then I want to wait for some of the 1.1 spec stuff in Lightning before I ship it because that simplifies a lot of the interfaces for clients especially around fee handling.\"}, {\"type\":\"heading\",\"text\":\"Library Structure\"}, {\"type\":\"paragraph\",\"text\":\"So at a high level what does rust-lightning look like? There\u2019s no runtime. A nice thing about Rust is there\u2019s no runtime, there\u2019s no background threading, there\u2019s no garbage collection, nothing like that. There\u2019s no JVM required. It is not like Go where you have these threads that need to be started and run garbage collection and all of those kind of things. Rust-lightning is entirely event driven. So you call into it and it doesn\u2019t do anything unless you\u2019re calling it. It doesn\u2019t have a background thread so it has to. This means it is embeddable everywhere. If you can compile to LLVM and you can compile C code to  your target you can run rust-lightning hopefully. There\u2019s a few more pieces to work out on that but you can run it anywhere including hardware wallets, including WASM that kind of thing. It\u2019s designed to be fairly modular. Especially the different pieces you might want to have separated or replace on your own. That means routing, if you want to do your own routing management, you want to do your own routing algorithm, you want to do your own routing table management. It is completely stubbed out. There\u2019s a simple interface for it. There\u2019s a default one provided that you can use or you can just build your own, no problem. The channel management is separated from the actual monitoring of the channels. The pieces that have to watch the chain and handle updates to onchain transactions is separate from the actual management of what the state of all your HTLCs is and what the state of all your channels is. This lets you very easily take updates from the channels so the channel manager gives you these updates that says \u201cHey I\u2019ve received new information that you need to make sure to watch the chain for\u201d and gives you that blob. Then you can figure out how you want to get that to the device that needs to watch the chain. Maybe you have multiple different devices that are watching the chain aka watchtowers. Maybe the actual channels are managed on a hardware device and you have a remote watchtower, something like that. This lets you have flexibility there of exactly how you want to integrate these things. So this is pseudo native watchtower support. Exactly what form watchtowers take is weird because there are a lot of different trade-offs in terms of what data you need to sign in advance and provide the watchtower. How much data it needs to store versus how much you\u2019re trusting the watchtower with respect to privacy. Maybe it could steal your funds versus storing a lot of data. There are a lot of trade-offs there and I think the next talk will cover that a little bit better. Hopefully most of that goes away with eltoo and other future work. Today it is complicated so there is not full flexibility on types of watchtower yet in rust-lightning but definitely if you trust the servers that are watching the chain for you or you trust the watchtowers it is very easy to spin up a bunch of different servers doing watchtowers. So disk writing, all the kind of system interaction pieces are handled on the client side. So rust-lightning doesn\u2019t figure out how to write stuff to disk. It just hands it to you and this allows you to have flexibility and say something like \u201cOk here\u2019s an update you need to go update your watchtowers\u201d and you can say \u201cActually I couldn\u2019t get in touch with the watchtower, please pause that channel\u201d so it has flexibility here. It turns out that is super complicated to get right and I will talk about that a little bit more when I go into some of the fun things we\u2019ve done with testing on rust-lightning. The handling of pausing channels for watchtower updates has actually been pretty useful in terms of being able to have flexibility around how you monitor your channels. I did mention rust-lightning doesn\u2019t do chain sync for you because a key user of potentially rust-lightning is existing wallets and I\u2019ve spoken to a number of existing wallets who are excited about this idea. But they all already have their own chain sync. They\u2019re all already SPV clients or maybe they use Electrum servers or whatever. This is designed to be flexible in rust-lightning. It gives you all the information you need of here\u2019s the transactions you need to watch for, here\u2019s exactly the scripts and the txids and whatever so that you can use Electrum servers, you can use Neutrino, you can use existing bloom filter stuff. It is all pretty flexible and you can choose exactly how you want to integrate with the Bitcoin chain. Also BYO, RNG and key creation. The goal is that rust-lightning doesn\u2019t make syscalls for you, it just needs malloc. It is not 100% there but it is getting close. That means you have to have your own RNG. But of course if you\u2019re doing a hardware wallet or something like that you\u2019re going to want to use the hardware features anyway so I\u2019m not going to try to guess what environment you\u2019re running in, you have to plug that in yourself. Finally the actual TCP handling is up to you as well. There is this easy interface that I\u2019ve written that looks exactly like select so you can just map this to an existing TCP socket handler super simple. Or you can consume the messages manually and this has been very useful for testing because we have a tonne of test harnesses that deliver messages out of order and delay message processing to simulate speed of light latency between nodes which has allowed us to be really flexible in terms of how we test the library.\"}, {\"type\":\"heading\",\"text\":\"Existing Wallets\"}, {\"type\":\"paragraph\",\"text\":\"In terms of the use case of having existing wallets that want to use rust-lightning. There\u2019s a few key elements of how rust-lightning fits into that. First of all as I mentioned hopefully it can live in any runtime. I\u2019m trying not to guess anything about the system you\u2019re running on. The goal is that it makes no syscalls except for it needs to be able to call malloc, no libc calls except for malloc. We\u2019re not quite there. We currently have some locking calls that we want to be able to stub out but we\u2019re getting close. So malloc, that makes it a little bit harder with hardware wallets but it\u2019s close. It is completely c-callable so you don\u2019t need to know anything about Rust. You just need to be able to know how to call a function in C and link a shared library which every language in the world should be able to do at this point. And finally, WASM. The goal is to be able to run this completely in a web browser. We\u2019re almost there, we need to remove one more dependency. You can compile rust-lightning and run a full Lightning node in your web browser. I don\u2019t know exactly why you\u2019d want to do this but in theory we support this. It leads to some excitement around running Lightning nodes in extensions and this will definitely allow you to sync different nodes. So maybe you have your Lightning node and you just keep an encrypted copy on a server of all the data for the Lightning node and when you\u2019re on your computer it runs in your little Chrome extension or in your React Native app and then when you go on your phone it downloads the latest state and it stops the one on your computer and runs it on your phone. It\u2019s just the same library that you\u2019re running everywhere and you can just compile it how you like.\"}, {\"type\":\"heading\",\"text\":\"Hardware Security\"}, {\"type\":\"paragraph\",\"text\":\"In the model of doing hardware or a more high assurance Lightning node. One key goal is to do what I have been calling semi-offline nodes so they\u2019re kind of offline but in practice have constant updates. So what I mean by this is maybe you have a HSM or maybe you have some other embedded device or maybe you have a regular server but it doesn\u2019t actually have an IP address, it can\u2019t connect to the internet. It only has one little line of communication out to maybe it\u2019s a regular computer or maybe it\u2019s a mother computer, maybe it\u2019s a mother server, maybe it\u2019s over serial, maybe it\u2019s over USB. You feed all of the communication with your peers over that line and this allows you to have a device where the only thing it can communicate with to the world is over the Lightning protocol to Lightning peers. It can\u2019t get hacked via some other means and maybe it is physically secured as well. So this is similar to how you might imagine a Ledger or a Trezor or a hardware wallet integrating Lightning. You run the node effectively on the device but it communicates to peers over whatever interface it has. So this is the reason why rust-lightning again doesn\u2019t make the actual TCP socket calls for you, it just tells you \u201cHere\u2019s bytes. Please send it to this peer\u201d or accepts incoming bytes from a peer. It is very easy to wrap around a TCP socket but you still have this flexibility to be able to do other crazy integration work. Of course this sidesteps the issue of how do you monitor the chain? One of the key aspects of the Lightning security model is you have to have something that is always monitoring the chain. And so you can\u2019t completely move over to something like a Ledger or a Trezor or a hardware wallet because it is not constantly online and it doesn\u2019t constantly get chain updates. So if it is offline for a while that is problematic. Of course this is even worse because there are some cases in Lightning where maybe you have a pending HTLC but your counterparty went offline and in order to claim that HTLC you need to go ahead and clear the chain before some timeout. That\u2019s even worse because you have to not only be monitoring the chain on long time periods but you might have a specific time where you need to broadcast this update if you haven\u2019t been able to get in touch with your peer in some time. In rust-lightning we try to get round this a little bit. We don\u2019t actually natively do this for you but one key approach you might imagine taking is if you have this hardware wallet or you have some device you can have pseudo trusted watchtowers. I\u2019m using the term watchtower overloaded a little bit here. It is kind of a trusted other half of your node. You can send it an encrypted copy of the data it needs to monitor for and it can sign that data, send it back to you and say \u201cYes I\u2019ve received it, I\u2019ve updated it.\u201d And then you\u2019re still not necessarily needing to trust the computer in-between the online computer but you need to trust that that other device is actively monitoring the chain and gets updates. This is still kind of nice because you can imagine if you\u2019re really going down the rabbit hole of running some crazy high assurance lightning node, maybe you have multiple copies of this kind of server. You have multiple things watching the chain for you in different geographic regions and so you need to be able to take this data that it needs to watch for, send it to multiple servers, get sign off from all those servers and then actually make progress on the channel. So rust-lightning supports pausing the channel temporarily until you\u2019ve updated the watching stuff, the chain monitor and then it will continue.\"}, {\"type\":\"heading\",\"text\":\"Testing Fun\"}, {\"type\":\"paragraph\",\"text\":\"So those are the two key use cases that are supported in rust-lightning. What I want to talk a little bit briefly about is some of the stuff we\u2019ve been working on in terms of testing and different approaches we\u2019ve taken from existing nodes that have kind of been enabled somewhat on accident by the structure of the library. So this wasn\u2019t something that I had as a goal of mine going in but it turns out just because this library is flexible, it doesn\u2019t have a runtime, it doesn\u2019t have any syscalls and so you don\u2019t have to do a bunch of setup work, it means we can run really great tests that literally can stand up ten nodes in the same process just by making four function calls. We don\u2019t have to go actually create daemons and wipe things on disk and move things around, anything like that. It has enabled us to write really fast, great tests all over the place. And also of course because we have this interface like I mentioned of getting messages and being able to handle those messages manually to send between peers, we can also reorder those messages, we can delay them and deliver them in specific orders really easily by moving lines of code around instead of having to actually sit in the middle of a TCP socket and hack up our daemon or have a bunch of testing code in the middle of our production code. We\u2019ve also played a lot with fuzzing, I guess I\u2019ve played a lot with fuzzing in rust-lightning. We obviously have fuzzers for all our message deserializers and stuff like that. For those who aren\u2019t familiar, fuzzing has been incredibly useful across the software world but mostly for finding vulnerabilities in things like image decompressors, image decoders, message deserializers, that sort of thing. And what it does is you write a program that takes as input some arbitrary string of bytes and you do something with those bytes and the fuzzer tries to make you crash. So if you have some image decoder or decompressor often times it will find a bug where you used too much memory, you have an out of memory condition and you have a DoS vulnerability there. Or maybe it will find a bug where you have some buffer overflow, something like that. Or whatever depending on the language you\u2019re writing in. Fuzzers have been amazing. You can go look up all of the various CVEs and vulnerabilities they\u2019ve found. We\u2019ve been playing a lot with them in rust-lightning and we have the standard ones of just make sure all of our message deserializers don\u2019t crash or don\u2019t use infinite memory. But we also have some allow nodes to do completely arbitrary things. So we have one fuzz target that runs a full node and can receive bytes on the wire. This allows you to literally do anything that another node could do to you possibly in a fuzzing environment where the fuzzer is trying to creatively crash your program and comes up with different inputs that might exercise different code paths. Fuzzers aren\u2019t that efficient as you might imagine, they\u2019re just shoving in random bytes. They\u2019re much smarter than shoving in random bytes but it is still shoving in random bytes. And so when you have these very large messages they\u2019re fairly slow and you don\u2019t have great code coverage. There\u2019s some new research on how to do fuzzing with a technique called taint tracking. If you\u2019re interested you should go Google this, it is actually incredibly fascinating. It is a great tool for building high assurance software. We are exploring that a little bit in rust-lightning but we haven\u2019t gotten that far. We also have a more recent fuzz target which tests for consistency of the protocol. So we can actually write little short snippets that allow the fuzzer to essentially write new test cases for us. The fuzzer can reorder the delivery of messages so that it simulates the speed of light. It can send payments, receive payments, things like that. And its goal is to find inconsistencies in the state machine of our channel. So you have two channels on both sides of a node. You have a channel and you have two nodes and your goal is to try to find a way to get the two nodes into some different state because they shouldn\u2019t be able to, they\u2019re sending messages to each other. But if they somehow end up disagreeing about what the current state is, that\u2019s clearly a bug in our state machine. It is probably exploitable because there\u2019s probably some case where we\u2019re forgetting about a HTLC or some funds. And this has been incredibly useful. We\u2019ve maybe copied twenty test cases out of this fuzzer into our regular test suite and found a number of bugs especially in our channel pausing stuff. So there\u2019s a lot of really exciting work that we\u2019ve been able to do in fuzzing in rust-lightning in addition to just standard unit tests and standard protocol tests. One final thing I wanted to mention for those of you who are interested in testing, the Rust ecosystem generally is, because it is a lot of engineers building often high assurance software, one thing that Rust has good tooling for or that there are good libraries for in Rust that don\u2019t exist in most other languages is a technique called mutation testing. Your goal is to test your tests by modifying the actual software and making sure that your tests fail. If you take your software and you flip some if conditions or you change some default initialization of some variables, your test should be able to catch that. Otherwise you don\u2019t have good test coverage. This is much more effective than just looking at standard branch coverage or standard coverage analysis of your code and can find a lot more details that you might have missed in testing and things you should add tests for. So this is future work that we\u2019d like to do on rust-lightning. If you\u2019re interested in writing really cool state of the art testing come talk to me. We\u2019d love contributors. So with that I was told I have to mention that Chaincode is running another residency program. We\u2019ve had great success with these in the past. Most of the people end up getting a job somewhere in the space. If you are really interested in Bitcoin and want to get really deep into the nitty gritty of protocol engineering in both Bitcoin and how everything works and how people think about it. And Lightning and other stuff. You should apply. It is residency.chaincode.com. It\u2019s about two weeks of intensive course-ish work where there\u2019ll be a tonne of talks by great speakers. Me and some of the other Chaincode folks and we have people coming into town just to speak to you. We\u2019re going to do it a little bit differently this time and there\u2019s going to be a bunch of project time so you can hang out in New York with us with some great mentors, some of the smartest people in the Bitcoin ecosystem will help you with whatever project you want to work on, whether it\u2019s rust-lightning or BetterHash or contributing to Bitcoin Core or other Lightning implementations or whatever cool project you want to do, you can come hang out with brilliant people and do that.\"}, {\"type\":\"heading\",\"text\":\"Q&A\"}, {\"type\":\"paragraph\",\"text\":\"Q - I\u2019m wondering about all of the upgrades coming up in SegWit version 1 and how that will change Lightning. How are you planning to upgrade the Rust library to handle all of the changes that are upcoming?\"}, {\"type\":\"paragraph\",\"text\":\"A - With rust-lightning not being production yet it means we can not bother supporting old school stuff and even ignoring SegWit version 1, with the Lightning 1.1 changes, some of those changes I want to have in rust-lightning and supported on the network before anyone starts using rust-lightning in production because it will simplify a lot of stuff about interfacing and making sure it is really easy to use rust-lightning and doesn\u2019t have fee disagreements. Also obviously eltoo and whatnot will hopefully make watchtowers orders of magnitude simpler and we can just throw out old code because no one is using it yet.\"}",
    "body": "\nFlexible Lightning in Rust\n\nSlides: <https://docs.google.com/presentation/d/154bMWdcMCFUco4ZXQ3lWfF51U5dad8pQ23rKVkncnns/edit#slide=id.p>\n\n<https://twitter.com/kanzure/status/1144256392490029057>\n\n# Introduction\n\nThanks for having me. I want to talk a little bit about a project I\u2019ve been working on for about a year called rust-lightning. I started it in December so a year and a few months ago. This is my first presentation on it so I\u2019m excited to finally get to talk about it a little bit.\n\n# Goals\n\nIt is yet another Lightning implementation because somehow we needed another one I guess or really not. But about a year and change ago I decided I want to learn Rust. Everyone is super excited about Rust. What is this thing? Maybe there is something here to it. I also wanted to learn a little bit about Lightning. We didn\u2019t have anyone at Chaincode who had worked on any Lightning things. I wanted to get into the meat of it because we were just a Bitcoin Core shop or research lab so it is nice to have people who know all the different pieces. I kind of figured there\u2019s this spec thing here but most of the implementations have been done by working with each other and it would be nice to have something that is done completely clean room just from the spec, just to see how good the spec is, to improve it, to provide feedback and see what kind of misconceptions I can come up with about how Lightning is supposed to work by just reading the spec without reading any of the other implementations. It turns out there were a number of them, the spec is good but it could use a little bit\u2026 Anyway I kind of got started and I started working on this and writing it. It was fun and I learned a lot about Rust and a lot about Lightning. I kind of realized there is this little niche in the Lightning node ecosystem that really isn\u2019t filled at all. That\u2019s to not be a wholesale node and provide people flexibility to integrate Lightning in the way they want. Today you can go take c-lightning and you can run it and it has a great interface and it works. Or you can take lnd and you can run it and you communicate over gRPC. You can take Eclair and even that has a lot of how it interacts with other peers built in and baked in and how it manages keys and all those things. There\u2019s not really a good Lightning implementation that you bring your own key creation and you figure out how you want the UX to work, you figure out how you want the disk storage to work, how exactly you want all the pieces to fit together. That\u2019s the niche I slipped into trying to fill with this project. The key initial supported use cases are first of all existing wallets. We have this big ecosystem of Bitcoin wallets out there, most of them don\u2019t support Lightning because how would they have supported Lightning a year ago? How are they going to go integrate Lightning without starting completely from scratch, getting all of these protocol details correct and doing a tonne of work to make sure they handle every possible edge case in Lightning correctly. So hopefully rust-lightning is just this easy thing that you can take off the shelf, you can integrate it tightly with all of your existing management of UTXO and chain state and everything. It deals with the rest for you. It deals with channel management and peer management and all of those good things. The other use case that I want to support a little bit better is flexibility around how you do, whether it\u2019s a hardware wallet or whether it\u2019s these partially offline nodes and I\u2019ll get into a little bit more of what I mean by that in a minute, but letting people have more high assurance or at least different security models around how they run their Lightning node instead of just I have an online server and I put funds in it and I trust it is not going to get hacked. That is where it has gone and it has made a lot of progress. It is mostly there. There\u2019s some stuff I want to change in terms of getting the last bits of onchain handling implemented and then I want to wait for some of the 1.1 spec stuff in Lightning before I ship it because that simplifies a lot of the interfaces for clients especially around fee handling.\n\n# Library Structure\n\nSo at a high level what does rust-lightning look like? There\u2019s no runtime. A nice thing about Rust is there\u2019s no runtime, there\u2019s no background threading, there\u2019s no garbage collection, nothing like that. There\u2019s no JVM required. It is not like Go where you have these threads that need to be started and run garbage collection and all of those kind of things. Rust-lightning is entirely event driven. So you call into it and it doesn\u2019t do anything unless you\u2019re calling it. It doesn\u2019t have a background thread so it has to. This means it is embeddable everywhere. If you can compile to LLVM and you can compile C code to  your target you can run rust-lightning hopefully. There\u2019s a few more pieces to work out on that but you can run it anywhere including hardware wallets, including WASM that kind of thing. It\u2019s designed to be fairly modular. Especially the different pieces you might want to have separated or replace on your own. That means routing, if you want to do your own routing management, you want to do your own routing algorithm, you want to do your own routing table management. It is completely stubbed out. There\u2019s a simple interface for it. There\u2019s a default one provided that you can use or you can just build your own, no problem. The channel management is separated from the actual monitoring of the channels. The pieces that have to watch the chain and handle updates to onchain transactions is separate from the actual management of what the state of all your HTLCs is and what the state of all your channels is. This lets you very easily take updates from the channels so the channel manager gives you these updates that says \u201cHey I\u2019ve received new information that you need to make sure to watch the chain for\u201d and gives you that blob. Then you can figure out how you want to get that to the device that needs to watch the chain. Maybe you have multiple different devices that are watching the chain aka watchtowers. Maybe the actual channels are managed on a hardware device and you have a remote watchtower, something like that. This lets you have flexibility there of exactly how you want to integrate these things. So this is pseudo native watchtower support. Exactly what form watchtowers take is weird because there are a lot of different trade-offs in terms of what data you need to sign in advance and provide the watchtower. How much data it needs to store versus how much you\u2019re trusting the watchtower with respect to privacy. Maybe it could steal your funds versus storing a lot of data. There are a lot of trade-offs there and I think the next talk will cover that a little bit better. Hopefully most of that goes away with eltoo and other future work. Today it is complicated so there is not full flexibility on types of watchtower yet in rust-lightning but definitely if you trust the servers that are watching the chain for you or you trust the watchtowers it is very easy to spin up a bunch of different servers doing watchtowers. So disk writing, all the kind of system interaction pieces are handled on the client side. So rust-lightning doesn\u2019t figure out how to write stuff to disk. It just hands it to you and this allows you to have flexibility and say something like \u201cOk here\u2019s an update you need to go update your watchtowers\u201d and you can say \u201cActually I couldn\u2019t get in touch with the watchtower, please pause that channel\u201d so it has flexibility here. It turns out that is super complicated to get right and I will talk about that a little bit more when I go into some of the fun things we\u2019ve done with testing on rust-lightning. The handling of pausing channels for watchtower updates has actually been pretty useful in terms of being able to have flexibility around how you monitor your channels. I did mention rust-lightning doesn\u2019t do chain sync for you because a key user of potentially rust-lightning is existing wallets and I\u2019ve spoken to a number of existing wallets who are excited about this idea. But they all already have their own chain sync. They\u2019re all already SPV clients or maybe they use Electrum servers or whatever. This is designed to be flexible in rust-lightning. It gives you all the information you need of here\u2019s the transactions you need to watch for, here\u2019s exactly the scripts and the txids and whatever so that you can use Electrum servers, you can use Neutrino, you can use existing bloom filter stuff. It is all pretty flexible and you can choose exactly how you want to integrate with the Bitcoin chain. Also BYO, RNG and key creation. The goal is that rust-lightning doesn\u2019t make syscalls for you, it just needs malloc. It is not 100% there but it is getting close. That means you have to have your own RNG. But of course if you\u2019re doing a hardware wallet or something like that you\u2019re going to want to use the hardware features anyway so I\u2019m not going to try to guess what environment you\u2019re running in, you have to plug that in yourself. Finally the actual TCP handling is up to you as well. There is this easy interface that I\u2019ve written that looks exactly like select so you can just map this to an existing TCP socket handler super simple. Or you can consume the messages manually and this has been very useful for testing because we have a tonne of test harnesses that deliver messages out of order and delay message processing to simulate speed of light latency between nodes which has allowed us to be really flexible in terms of how we test the library.\n\n# Existing Wallets\n\nIn terms of the use case of having existing wallets that want to use rust-lightning. There\u2019s a few key elements of how rust-lightning fits into that. First of all as I mentioned hopefully it can live in any runtime. I\u2019m trying not to guess anything about the system you\u2019re running on. The goal is that it makes no syscalls except for it needs to be able to call malloc, no libc calls except for malloc. We\u2019re not quite there. We currently have some locking calls that we want to be able to stub out but we\u2019re getting close. So malloc, that makes it a little bit harder with hardware wallets but it\u2019s close. It is completely c-callable so you don\u2019t need to know anything about Rust. You just need to be able to know how to call a function in C and link a shared library which every language in the world should be able to do at this point. And finally, WASM. The goal is to be able to run this completely in a web browser. We\u2019re almost there, we need to remove one more dependency. You can compile rust-lightning and run a full Lightning node in your web browser. I don\u2019t know exactly why you\u2019d want to do this but in theory we support this. It leads to some excitement around running Lightning nodes in extensions and this will definitely allow you to sync different nodes. So maybe you have your Lightning node and you just keep an encrypted copy on a server of all the data for the Lightning node and when you\u2019re on your computer it runs in your little Chrome extension or in your React Native app and then when you go on your phone it downloads the latest state and it stops the one on your computer and runs it on your phone. It\u2019s just the same library that you\u2019re running everywhere and you can just compile it how you like.\n\n# Hardware Security\n\nIn the model of doing hardware or a more high assurance Lightning node. One key goal is to do what I have been calling semi-offline nodes so they\u2019re kind of offline but in practice have constant updates. So what I mean by this is maybe you have a HSM or maybe you have some other embedded device or maybe you have a regular server but it doesn\u2019t actually have an IP address, it can\u2019t connect to the internet. It only has one little line of communication out to maybe it\u2019s a regular computer or maybe it\u2019s a mother computer, maybe it\u2019s a mother server, maybe it\u2019s over serial, maybe it\u2019s over USB. You feed all of the communication with your peers over that line and this allows you to have a device where the only thing it can communicate with to the world is over the Lightning protocol to Lightning peers. It can\u2019t get hacked via some other means and maybe it is physically secured as well. So this is similar to how you might imagine a Ledger or a Trezor or a hardware wallet integrating Lightning. You run the node effectively on the device but it communicates to peers over whatever interface it has. So this is the reason why rust-lightning again doesn\u2019t make the actual TCP socket calls for you, it just tells you \u201cHere\u2019s bytes. Please send it to this peer\u201d or accepts incoming bytes from a peer. It is very easy to wrap around a TCP socket but you still have this flexibility to be able to do other crazy integration work. Of course this sidesteps the issue of how do you monitor the chain? One of the key aspects of the Lightning security model is you have to have something that is always monitoring the chain. And so you can\u2019t completely move over to something like a Ledger or a Trezor or a hardware wallet because it is not constantly online and it doesn\u2019t constantly get chain updates. So if it is offline for a while that is problematic. Of course this is even worse because there are some cases in Lightning where maybe you have a pending HTLC but your counterparty went offline and in order to claim that HTLC you need to go ahead and clear the chain before some timeout. That\u2019s even worse because you have to not only be monitoring the chain on long time periods but you might have a specific time where you need to broadcast this update if you haven\u2019t been able to get in touch with your peer in some time. In rust-lightning we try to get round this a little bit. We don\u2019t actually natively do this for you but one key approach you might imagine taking is if you have this hardware wallet or you have some device you can have pseudo trusted watchtowers. I\u2019m using the term watchtower overloaded a little bit here. It is kind of a trusted other half of your node. You can send it an encrypted copy of the data it needs to monitor for and it can sign that data, send it back to you and say \u201cYes I\u2019ve received it, I\u2019ve updated it.\u201d And then you\u2019re still not necessarily needing to trust the computer in-between the online computer but you need to trust that that other device is actively monitoring the chain and gets updates. This is still kind of nice because you can imagine if you\u2019re really going down the rabbit hole of running some crazy high assurance lightning node, maybe you have multiple copies of this kind of server. You have multiple things watching the chain for you in different geographic regions and so you need to be able to take this data that it needs to watch for, send it to multiple servers, get sign off from all those servers and then actually make progress on the channel. So rust-lightning supports pausing the channel temporarily until you\u2019ve updated the watching stuff, the chain monitor and then it will continue.\n\n# Testing Fun\n\nSo those are the two key use cases that are supported in rust-lightning. What I want to talk a little bit briefly about is some of the stuff we\u2019ve been working on in terms of testing and different approaches we\u2019ve taken from existing nodes that have kind of been enabled somewhat on accident by the structure of the library. So this wasn\u2019t something that I had as a goal of mine going in but it turns out just because this library is flexible, it doesn\u2019t have a runtime, it doesn\u2019t have any syscalls and so you don\u2019t have to do a bunch of setup work, it means we can run really great tests that literally can stand up ten nodes in the same process just by making four function calls. We don\u2019t have to go actually create daemons and wipe things on disk and move things around, anything like that. It has enabled us to write really fast, great tests all over the place. And also of course because we have this interface like I mentioned of getting messages and being able to handle those messages manually to send between peers, we can also reorder those messages, we can delay them and deliver them in specific orders really easily by moving lines of code around instead of having to actually sit in the middle of a TCP socket and hack up our daemon or have a bunch of testing code in the middle of our production code. We\u2019ve also played a lot with fuzzing, I guess I\u2019ve played a lot with fuzzing in rust-lightning. We obviously have fuzzers for all our message deserializers and stuff like that. For those who aren\u2019t familiar, fuzzing has been incredibly useful across the software world but mostly for finding vulnerabilities in things like image decompressors, image decoders, message deserializers, that sort of thing. And what it does is you write a program that takes as input some arbitrary string of bytes and you do something with those bytes and the fuzzer tries to make you crash. So if you have some image decoder or decompressor often times it will find a bug where you used too much memory, you have an out of memory condition and you have a DoS vulnerability there. Or maybe it will find a bug where you have some buffer overflow, something like that. Or whatever depending on the language you\u2019re writing in. Fuzzers have been amazing. You can go look up all of the various CVEs and vulnerabilities they\u2019ve found. We\u2019ve been playing a lot with them in rust-lightning and we have the standard ones of just make sure all of our message deserializers don\u2019t crash or don\u2019t use infinite memory. But we also have some allow nodes to do completely arbitrary things. So we have one fuzz target that runs a full node and can receive bytes on the wire. This allows you to literally do anything that another node could do to you possibly in a fuzzing environment where the fuzzer is trying to creatively crash your program and comes up with different inputs that might exercise different code paths. Fuzzers aren\u2019t that efficient as you might imagine, they\u2019re just shoving in random bytes. They\u2019re much smarter than shoving in random bytes but it is still shoving in random bytes. And so when you have these very large messages they\u2019re fairly slow and you don\u2019t have great code coverage. There\u2019s some new research on how to do fuzzing with a technique called taint tracking. If you\u2019re interested you should go Google this, it is actually incredibly fascinating. It is a great tool for building high assurance software. We are exploring that a little bit in rust-lightning but we haven\u2019t gotten that far. We also have a more recent fuzz target which tests for consistency of the protocol. So we can actually write little short snippets that allow the fuzzer to essentially write new test cases for us. The fuzzer can reorder the delivery of messages so that it simulates the speed of light. It can send payments, receive payments, things like that. And its goal is to find inconsistencies in the state machine of our channel. So you have two channels on both sides of a node. You have a channel and you have two nodes and your goal is to try to find a way to get the two nodes into some different state because they shouldn\u2019t be able to, they\u2019re sending messages to each other. But if they somehow end up disagreeing about what the current state is, that\u2019s clearly a bug in our state machine. It is probably exploitable because there\u2019s probably some case where we\u2019re forgetting about a HTLC or some funds. And this has been incredibly useful. We\u2019ve maybe copied twenty test cases out of this fuzzer into our regular test suite and found a number of bugs especially in our channel pausing stuff. So there\u2019s a lot of really exciting work that we\u2019ve been able to do in fuzzing in rust-lightning in addition to just standard unit tests and standard protocol tests. One final thing I wanted to mention for those of you who are interested in testing, the Rust ecosystem generally is, because it is a lot of engineers building often high assurance software, one thing that Rust has good tooling for or that there are good libraries for in Rust that don\u2019t exist in most other languages is a technique called mutation testing. Your goal is to test your tests by modifying the actual software and making sure that your tests fail. If you take your software and you flip some if conditions or you change some default initialization of some variables, your test should be able to catch that. Otherwise you don\u2019t have good test coverage. This is much more effective than just looking at standard branch coverage or standard coverage analysis of your code and can find a lot more details that you might have missed in testing and things you should add tests for. So this is future work that we\u2019d like to do on rust-lightning. If you\u2019re interested in writing really cool state of the art testing come talk to me. We\u2019d love contributors. So with that I was told I have to mention that Chaincode is running another residency program. We\u2019ve had great success with these in the past. Most of the people end up getting a job somewhere in the space. If you are really interested in Bitcoin and want to get really deep into the nitty gritty of protocol engineering in both Bitcoin and how everything works and how people think about it. And Lightning and other stuff. You should apply. It is residency.chaincode.com. It\u2019s about two weeks of intensive course-ish work where there\u2019ll be a tonne of talks by great speakers. Me and some of the other Chaincode folks and we have people coming into town just to speak to you. We\u2019re going to do it a little bit differently this time and there\u2019s going to be a bunch of project time so you can hang out in New York with us with some great mentors, some of the smartest people in the Bitcoin ecosystem will help you with whatever project you want to work on, whether it\u2019s rust-lightning or BetterHash or contributing to Bitcoin Core or other Lightning implementations or whatever cool project you want to do, you can come hang out with brilliant people and do that.\n\n# Q&A\n\nQ - I\u2019m wondering about all of the upgrades coming up in SegWit version 1 and how that will change Lightning. How are you planning to upgrade the Rust library to handle all of the changes that are upcoming?\n\nA - With rust-lightning not being production yet it means we can not bother supporting old school stuff and even ignoring SegWit version 1, with the Lightning 1.1 changes, some of those changes I want to have in rust-lightning and supported on the network before anyone starts using rust-lightning in production because it will simplify a lot of stuff about interfacing and making sure it is really easy to use rust-lightning and doesn\u2019t have fee disagreements. Also obviously eltoo and whatnot will hopefully make watchtowers orders of magnitude simpler and we can just throw out old code because no one is using it yet.\n\n\n",
    "body_type": "markdown",
    "created_at": "2019-02-07T00:00:00.000Z",
    "domain": "https://btctranscripts.com/",
    "url": "https://btctranscripts.com/advancing-bitcoin/2019/2019-02-07-matt-corallo-rust-lightning",
    "categories": [
        "conference"
    ],
    "tags": [
        "lightning"
    ],
    "media": "https://www.youtube.com/watch?v=w_To_bnXjvk",
    "authors": [
        "Matt Corallo"
    ],
    "indexed_at": "2024-03-21T16:33:35.850Z",
    "transcript_by": "Michael Folkson",
    "summary": "In a recent podcast, Matt Corallo shed light on the innovative strides being made within the Bitcoin Lightning Network through the development of rust-lightning, a project that stands out for its flexibility, security, and integration capabilities. Developed primarily in Rust, this initiative is not only a testament to Corallo's dedication to understanding the intricacies of both the programming language and the Lightning Network but also his commitment to contributing to the ecosystem's growth. Rust-lightning offers a unique approach by moving away from the conventional one-size-fits-all node design, thereby providing developers with the ability to customize key aspects such as key management and disk storage to fit their specific requirements.\n\nOne of the most compelling features of rust-lightning is its architectural design, which emphasizes modularity and ease of integration. This design philosophy ensures that the library can operate without a runtime, making it suitable for deployment across a wide range of platforms, including hardware wallets and WebAssembly (WASM). By segmenting functions such as routing and channel monitoring, rust-lightning allows for specialized implementations, affording users greater control over their operational environments and security models.\n\nMoreover, rust-lightning's compatibility with existing wallets and its ability to integrate into diverse runtime environments without extensive system calls underscore its versatility. The project aims to extend its functionality to web browsers through WASM, potentially revolutionizing the way Lightning nodes operate by facilitating their use in browser extensions or mobile applications. Additionally, the introduction of semi-offline nodes offers a novel approach to enhancing the security of Lightning node operations, reducing their exposure to internet-based threats and mirroring the protective measures of hardware wallets.\n\nCorallo also delves into the critical necessity of continuous chain monitoring within the Lightning Network to safeguard against potential security breaches. To overcome the limitations of hardware wallets in this regard, rust-lightning employs pseudo-trusted watchtowers for decentralized monitoring. This innovative solution enhances network robustness while ensuring operational integrity during offline periods.\n\nThe podcast further explores rust-lightning's commitment to rigorous testing and development practices. The absence of runtime dependencies facilitates the simulation of complex network scenarios, improving system reliability and stability. The adoption of fuzzing techniques has been particularly effective in identifying vulnerabilities, highlighting the importance of advanced testing methodologies like mutation testing in the ongoing development of rust-lightning.\n\nIn closing, Corallo extends an invitation to individuals interested in contributing to the Bitcoin protocol engineering and rust-lightning development through Chaincode's residency program. This initiative represents a broader effort to foster talent and innovation within the Bitcoin ecosystem, emphasizing the crucial role of community collaboration and advanced testing in enhancing the functionality, security, and user-friendliness of the Lightning Network.\n\nThrough these insightful discussions, Matt Corallo underscores the significant advancements being made in the Lightning Network's development, driven by a commitment to technical excellence and community engagement. Rust-lightning emerges as a beacon of innovation, promising a more flexible, secure, and inclusive future for Bitcoin's evolving landscape."
}