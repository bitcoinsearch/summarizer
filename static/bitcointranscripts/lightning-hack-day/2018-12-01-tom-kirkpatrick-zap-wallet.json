{
    "created_at": null,
    "media": "https://www.youtube.com/watch?v=OhRPZs0cWwQ",
    "title": "Zap Desktop: A look under the hood",
    "body": "## Introduction\n\nI\u2019m Tom. I\u2019ve been working on the Zap desktop wallet for the last six months or so. If you\u2019re not familiar, we\u2019re trying to build consumer facing Lightning applications. We\u2019ve currently got an iOS app and a desktop wallet. They\u2019re pretty similar, the interface is pretty similar between them but they\u2019ve got a slightly different focus. I\u2019ve been working on the desktop wallet. Can I just get an idea of how many people here have used Zap? Quite a lot. That\u2019s probably about 80-90%, that\u2019s awesome.\n\n## Overview\n\nI want to take you through a couple of different things. First I want to talk about my experience of building on Lightning and what I found is involved in that. Then I\u2019m going to take a look under the hood of Zap. I\u2019m going to get a little technical but I\u2019m not going to be showing code samples or anything like that. I want to give you a sense of how it\u2019s interacting with Lightning and what the communication stream is like and what we\u2019re doing underneath the interface that you guys see. I\u2019m going to show you some of the new features and things we\u2019ve been working on. I\u2019m going to touch on some of the challenges that I\u2019ve faced and some of the insights that I\u2019ve got from working on this stuff over the last few months.\n\n## Basically a web app\n\nSo starting off, building on Lightning. The first thing I would say is that it is basically a web app at its core. Technically it is a React application and it is running in Electron. If you\u2019ve done web development before and you\u2019re familiar with client-server architecture it is pretty similar. When you\u2019re building websites you\u2019re maybe using Stripe API or PayPal API to make payments, we\u2019re just using lnd under the hood. Everything you\u2019re doing in the interface is literally sending messages over to lnd and lnd is doing all the interfacing with the Lightning Network. We\u2019re getting realtime data back from lnd and we\u2019re presenting that and allowing people to interact with the network without really knowing that\u2019s what they\u2019re doing. The tools and processes that we\u2019re using to build out the app are really similar to if you\u2019ve done any web development. It\u2019s literally a Javascript application. You guys will probably be familiar with that sort of thing. We\u2019re running continuous integration with Travis and AppVeyor. We\u2019re using Jest for our automated testing. We have a pretty much zero touch deployment process whereby when we commit everything to GitHub, every commit triggers a build which triggers the test suite which triggers packaging up the application into the Electron package. That gets uploaded to GitHub. We always have the latest version of Zap available on GitHub for download. We actually just publish, when we\u2019re ready to do a release, we publish the most recent version. We\u2019ve always got those builds available in the background.\n\n## The 1000\u2019 view\n\nEssentially it is really just a wrapper around lnd. We\u2019ve built into it support for running lnd locally on your machine so you can run lnd on here via zap-desktop. You can also connect it to a remote node as well. In both cases it is just working as a remote control. The difference is that when you\u2019re running lnd locally you\u2019re communicating with gRPC locally on that node. We basically have two different Javascript processes running. We have the browser environment which is basically a Chromium environment that runs inside Electron. That\u2019s giving the browser window, essentially what you\u2019re seeing is a web browser with the React application running in it. We\u2019ve got lnd running in the background and we\u2019re using the gRPC API to communicate between the two. Because we\u2019re managing lnd as an external process so we have the lnd binary packaged up in that Electron app, we literally use Node spawn so we have full Node.js facilities within there. We use Node, we spawn that process. We have a finite state machine that sits on top of that lnd process so that we can more easily manage transitioning it from one state to another. When we\u2026  the app we set the state machine in a ready state and then when you access a wallet we transition to a running state as we start the process. We attach some event listeners to the lnd log output and we monitor the process. We can stop it and restart it and things like that. We\u2019ve also got some supporting infrastructure, more backend stuff. Specifically we have a cluster of btcd nodes which are our Bitcoin full nodes. If anyone is not familiar with btcd, it is a full node implementation similar to Bitcoin Core. We have a few instances of that running. We currently run them on the Google Cloud environment so we have Docker containers. If you go to our GitHub we\u2019ve got two different Docker containers. We\u2019ve got a lnd one and a btcd one. We use Kubernetes to deploy those out to Google Cloud. The actual full blockchain data is stored in Google persistent drives which we attach the stateful drives to the node instances up on Google Cloud. We have those because when you\u2019re running lnd locally on the machine, lnd connects to our btcd nodes. It connects to a couple of them in parallel and it synchronizes the blockchain data from those nodes. If you\u2019re using the remote node it doesn\u2019t touch our btcd nodes at all because you\u2019re connecting to your own setup where you\u2019ve got your own full node.\n\n## Bootstrapping\n\nDiving a little further under the hood. When you start the app, the first thing we do is we go through some sanity checks. We check the filesystem, we check that your wallet is aware. We expect it to be so when we start lnd we create a wallet which creates a lnd directory in a specific location. It actually gets stored in the user data directory from Electron. It will be in a slightly different place depending on which environment you\u2019re running on, Mac or Windows or whatever. It\u2019s essentially application state data. We also use IndexedDB. Within the Electron browser environment we\u2019re using IndexedDB which is a native browser based database. In that we store some persistent data. We don\u2019t store a lot but we store your wallet configuration. When you spin up a remote connection you\u2019ve got to tell lnd where\u2019s your macaroon, where\u2019s your certificate, things like that. That configuration we store in IndexedDB. We store some user preference data, what theme you\u2019re using whether it is the light theme or the dark theme. What language you\u2019re using or what currency you\u2019ve selected. There\u2019s only a small amount of data that we\u2019re using currently. Previously we were using files on the filesystem, we had a JSON file with a little bit of config in there. We found that as we started to build it out more we needed something with a bit more of a rich API than just accessing a file. IndexedDB is really lightweight and built into the Chromium environment so we\u2019re using that for our persistent data. As we start to build things out more there are probably some nice things we can do by having access to that database.\n\n## Onboarding\n\nThe next thing once we\u2019ve booted up the app is we send the user into this onboarding process. I think this screen embodies what we\u2019re trying to do with Zap which is providing something simple and easy for end users who aren\u2019t so technical. I think we\u2019re partly the way there. There are a lot of things that can be done to continue to make it more user friendly. There are a couple of basic options whether you want to create a wallet, import a wallet or connect to a remote node. We have a form wizard to collect up that data. We collect up the data, we store it in Redux within React. We store that data in Redux which is the persistent data in the browser while we\u2019re going through this process. Once we get through this process, we spawn the lnd. If you choose to select the local node\u2026 this is where we start to spin up lnd. We spawn a lnd process which basically gets gRPC running up on port\u2026 We actually select a random port. It will be somewhere around the 10009 range which is the default port. We have a range of ports that we use. We scan for a free port, start up lnd which gives us that gRPC interface. We make an API call into it and we tell it to generate a seed. We spit that back to the renderer process and we present that on the screen for the user and obviously ask them to write it down. Then we actually kill that lnd process. That is a new thing we\u2019ve started doing because some of the stuff I\u2019ll show you in a bit, some of the new stuff, you can move in and out of this part of the app. It is something I\u2019ve been working on recently. I\u2019m really interested if someone has a better way of doing this. If we just want to generate a seed, spinning up a binary process and getting access to an API and connecting to gRPC and making an API call, it seems like overkill just to generate a seed. If there was a native Javascript library we could use\u2026\n\nQ - There\u2019s a BIP 39 Javascript library. BitcoinJS can probably do it or the other one?\n\nA - The seed format is slightly different for lnd I believe. They have an aezeed. It\u2019s not standard BIP 39. These things will come\n\nQ - Then you\u2019re out of luck. It\u2019s probably just one little Go file that maybe could be converted to Javascript. To WebAssembly? That\u2019s a bit overkill maybe too but sounds like fun.\n\nA - If someone wants to pick it up we\u2019ll happily accept it.\n\nThat\u2019s what is happening here. You\u2019re connecting to a remote server. Currently it works and is functional. We get a lot of support requests in Slack for people trying to figure out how to do this. If you ever try to connect to a remote node you\u2019ve got to get three key pieces of information. You need to know the hostname and the IP address of the machine where lnd is running. You need to know the port where lnd is running. You need to get a TLS certificate and an admin macaroon file from that server. You need to copy those to your machine and you need to tell Zap where those files are. Even in saying that you can hear the friction that is involved in that. We\u2019re trying to build something that is consumer facing, that\u2019s an easy to use Lightning wallet. It\u2019s really not easy to use.\n\nQ - If it runs on your own machine, I assume these are all\u2026\n\nA - This is the point. This is the case where you are connecting to a remote node. Imagine you\u2019ve got a piece of hardware at home that is running a full node for you and from your laptop wherever you are, you just want to be able to connect to that. Or you\u2019ve got a BTCPay Server instance or anywhere where you\u2019ve got a remote node. In order to do this you need to shell into that node. You need to navigate into the lnd directory. You need to find these two specific files. You\u2019ve got to copy them over to your local machine. You\u2019ve now got to store them somewhere on your local machine. You\u2019ve got to enter in the path to where they are. We could have a button where you click browse and you could navigate to the file. You can see the friction in that. Also that\u2019s inherently insecure because if you think about it if you\u2019ve got those files:  the TLS file and the admin macaroon, you basically have full control over that Lightning node. Whoever has those files can control the node. They are your keys essentially in a sense. We\u2019re asking users to copy them across a network and that\u2019s going to be pretty insecure in most situations and we\u2019re asking people to store them somewhere. Where do they put them? There\u2019s no standard place. This is the current situation and there are definitely things we can do to try to improve that process.\n\nQ - The whole point of macaroons is that you can give partial permissions? The lnd server itself should be able to generate some thing that you download or some QR code?\n\nA - It can. But in order to have a wallet like Zap you need a macaroon file which gives you permission to send money. Anyone who has got that macaroon now has permission to send money. There\u2019s no way around that. If you want a wallet you\u2019ve got to be able to send right? It is the most basic functionality.\n\nQ - Why are you saving them as files?\n\nA - That\u2019s what we do currently. We can certainly use the operating system\u2019s private store which would be a better solution. But the user has also still got to get that data to us somehow. We could rather than ask you to enter in a path to a file, we could have somewhere they just paste in something. It gets a little more complex because the macaroon is actually a binary file so you can\u2019t copy and paste binary data into a field in a web browser. You can base64 encode it. This library here zapconnect is a library we wrote to help this process. zapconnect is a little Go application that\u2019s compiled into a binary. You can install zapconnect on your lnd node where lnd is running. When you run zapconnect it will generate a QR code for you that is a representation of the macaroon, the certificate and the connection: the hostname, port, all these bits of information. They\u2019re encoded in the QR code. With the iOS app you can just scan that. In the iOS app it is pretty frictionless. You install zapconnect on your Lightning node, you run zapconnect, you get a QR code and you go connect with your phone and you just scan it.\n\nQ - How do they do hole punching on iOS because you have to have an open port? We had this problem in the 90s, it resurfaces\u2026\n\nA - It\u2019s another of the questions we get all the time in Slack. There are a few different pitfalls here. One is people have got to open up their port. They\u2019ve got to make sure their firewall is forwarding packets. It is definitely fraught with difficulty.\n\nQ - I don\u2019t know if macaroons support this but what you could do is generate a private key on the desktop app and then give the public key to the lnd server and then make it generate a macaroon that says only the signer of this public key can communicate with me. At least then you\u2019re not sending any private keys over the wire, just public keys.\n\nA - That\u2019s an interesting idea.\n\nSo that connect works really well with the mobile app. There\u2019s two ways you can run it. You can generate a QR code. You can also generate a JSON snippet as well which you can copy and paste. That JSON snippet contains the macaroon in it as well. That\u2019s a really interesting idea, maybe we can chat about that afterwards.\n\nQ - I read the macaroon paper like ten years ago so don\u2019t interrogate me on it but I remember that they said you can have your Flickr photo album and then you can give somebody a macaroon that\u2019s as if you\u2019re logged in with your Yahoo account or your mom\u2019s account. They had some fancy ideas about permissions to solve this type of problem.\n\n## BTCPay Server\n\nOne of the final things that we built into the app in terms of connectivity is we built an integration with BTCPay Server. This is another way around this issue. We worked with Nicolas who is the developer of BTCPay Server to build out this configuration format. He now has in BTCPay\u2026 BTCPay is like a store that merchants can use to really easily spin up a Lightning node and have a store and point-of-sale device and things like that. We\u2019re seeing a lot of merchants using that. In BTCPay you can go in and say \u201cshow me my connection string\u201d. It will show you a QR code or something that you can copy and paste. You can just copy that, paste it directly into here and hit next and you\u2019re done. It\u2019s a bit more frictionless but that only works because on BTCPay they\u2019ve already got the infrastructure to generate this\u2026 It\u2019s basically doing what the zapconnect library is doing, something very similar, generating something that you can copy and paste over.\n\n## Syncing\n\nSo once you\u2019ve made your connection the next thing we do is we start synchronizing. If you\u2019re running lnd locally then we go into lnd synchronization process. It is something that was really tricky to build. Our implementation of this is hacky to say the best. The problem is that with lnd you\u2019ve got no idea how far through the synchronization process it really is. The way that we do this is we attach a listener. We\u2019ve got the lnd process running locally on the machine and we attach a listener to the standard output and the standard error of the lnd process. We run regex on every single line of log output and we\u2019re basically listening out for things that give us some kind of hints on what\u2019s happening in the sync process. We\u2019ve got a list of probably 15 or 20 log messages that we know are interesting to us and give us a hint as to whether a new block header has just been downloaded or some commitment filters have been downloaded. It would be nice if lnd had a stream that you could just connect to. lnd has bidirectional streaming like WebSockets where you can get data fed to you in realtime. They have it for some stuff like transactions and invoices and channel data I think you can get data to stream for you. You can\u2019t get any of this state data streamed to you currently. PR 1355 is trying to build support for Prometheus which is a monitoring system which allows you to tap in and get all kinds of metrics from lnd about memory usage. I think they are talking about including things like sync data and stuff like that. If there was something like that and that was exposed over the gRPC interface we\u2019d get a lot more insights into what\u2019s going on in lnd. At the moment it is pretty rudimentary and it\u2019s limited because we can only do that on a local process we\u2019re running. If we\u2019ve connected to a remote node we\u2019ve got no way of knowing what\u2019s going on in that. lnd has an API call that\u2019s called getinfo and when you run that it has a flag in there that says \u201csynced to chain\u201d. It\u2019s true or it\u2019s false. When the synchronization process takes several minutes you need to give the user some feedback as to what is going on. Another shortcoming that we found as well is that even just knowing what the current block height is, what\u2019s the latest block on the blockchain, what\u2019s the current block height number? When you connect to lnd and it starts synchronizing, lnd will tell you what it thinks is the latest block. It will tell you the latest block that it has. But if lnd itself is still in the process of synchronizing with the blockchain, the latest block that it has might not be the actual latest block. So we have to make a call out to a block explorer. I think we use blockchain.info and we figure out what the latest block is so we can show the progress incrementing. Even that is fraught with challenges because we found cases where blockchain.info would go down. So we actually now make three different API calls out to three separate block explorers. Whichever one gives us a result back first we use that to assume that\u2019s the current block height and we start pulling\u2026\n\nQ - Why are you not just pinging the full node?\n\nA - We don\u2019t have access to the full node. We\u2019re only connected directly to lnd and lnd might be talking to a full node that\u2019s on a different machine somewhere.\n\nQ - lnd cannot relay that? It sounds like a simple pull request\n\nA - When we\u2019re running lnd on here, we\u2019re running it in Neutrino mode and that\u2019s basically talking to our btcd servers.\n\nQ - You said you had several btcd running on Google Cloud. You can connect to those?\n\nA - Yeah we can. There are different places we can get that data from but it would be nice if lnd\u2026 Because lnd is our primary interface for everything Lightning we can do 90% of stuff but it\u2019s that extra 10% where we have to figure out workarounds whether it\u2019s calling btcd\u2026\n\nQ - Where is the Neutrino protocol coming in? The lnd node on your local machine is connected through Neutrino to the rest of the Bitcoin network?\n\nA - When you\u2019re running it locally you\u2019re running lnd locally and lnd is running as a Neutrino client which is connected to our btcd full nodes. Neutrino is the light client implementation between lnd and the full nodes.\n\nQ - Can lnd also be run with a local full node? It doesn\u2019t use any of the Neutrino stuff?\n\nA - That\u2019s right but we don\u2019t want to be downloading gigabytes of data. When you use Neutrino with testnet, most of my lnd directories are 400MB or something like that. You can download that pretty quickly. This currently takes about 5 minutes on testnet. If I\u2019d have done this a couple of months ago that would have taken about 15 minutes. There\u2019s a lot of improvements coming. What they\u2019ve done is they\u2019ve now made it so that Neutrino can pull the block headers and the commitment filters in parallel and it can pull them from multiple btcd nodes at the same time. So we\u2019re getting 4x what we used to get. They\u2019re starting to work more actively on the Neutrino support so I think there will be some more improvements. That\u2019s testnet as well so mainnet is much smaller and would be faster again.\n\n## Wallet\n\nAnother thing to point out here is that on the right you\u2019ve got the channel management piece. The idea here is that once lnd has built up a picture of the network which as I said can take some time, then you can go and start establishing channels with nodes. If you turn on autopilot it will do it for you. By default we have it set, I think we just use the lnd defaults which allocate 60% of your funds over a maximum of 5 channels or something like that. It should theoretically give you a good route into the network but in practice that doesn\u2019t really happen at the moment. The channel management piece - you can click on one of these channels and you can see how much balance is in each channel and things like that. Ultimately we\u2019d like that to disappear into the background. Maybe we can collapse it or something. Maybe eventually we can hide it away in an advanced settings page. Currently there\u2019s literally no way you can use the wallet without being able to inspect your channels and manage them manually. That speaks to a bigger point which is it is difficult for you to use the wallet without knowing actually what a channel is. We\u2019re talking about building things for mainstream. If you need to know what channels are we\u2019re not there yet.\n\n## Pay / Request\n\nI wanted to show you a couple of new bits and pieces that we\u2019ve been working on. Some of this is already in the master branch, some of this is going through review at the moment. The first thing is the payment and the request forms, if you\u2019re familiar with Zap currently you might see some differences here. We started building out support for fee estimation which we can get about 50% of the way there currently. In terms of making offchain payments like Lightning payments what we do is we send the payment request to lnd, we use the queryroutes API call. We ask lnd to give us a list of up to ten routes and it will return those to us in order of lowest fee to highest fee. We can then present the user with the lowest fee that we\u2019ve got and the highest fee that we\u2019ve got. We give them the range of what we think it is going to be. When they hit send and we send the payment we take the maximum fee that we got from our list of ten routes and we apply that as a fee limit. In the current version of Zap that you guys might have, when you actually send the payment we just blindly spit it out to the network. If it finds a route it will send on that route regardless of what the fee is. Here we\u2019re showing the user upfront what\u2019s the possible range. We generally see that this is between 1 and 3 satoshis, something like that. They\u2019re pretty low but it is important if we\u2019re showing the user it is between 1 and 3 satoshis, we\u2019ve got to cap it at 3. When we make the sendpayment call into lnd we tell it the maximum fee that we\u2019re going to apply which is the highest of the fees that we got back from queryroutes. If it manages to send it over one of those ten routes then fine. When you tell lnd to send a payment it will keep trying routes until it finds one that works or it times out. So we make sure we put in a hard stop in if the fee limit has been reached. In terms of the onchain fees we\u2019ve had some challenges here because lnd doesn\u2019t currently provide a fee estimation interface on REST or gRPC or whatever. So there is no way for us to know upfront what transaction fee is going to be applied. More specifically what we do currently in this latest implementation is we call out to 21\u2019s fee estimation API. We find out what the current estimated fee is to get something in within a few blocks. We can get that per byte fee rate whether it is 5 satoshis per byte or something like that. We can find out what that is but what we can\u2019t do is generate the transaction upfront. We can\u2019t know how big the transaction is going to be and therefore how much the satoshi per byte fee extrapolates out to the full cost of the transaction.\n\nQ - Why can\u2019t you know the size of the transaction?\n\nA - Because lnd doesn\u2019t let you create a transaction upfront currently. With lnd you can just say \u201cmake payment\u201d. Inside lnd it creates the transaction, it does the fee estimation, it applies the fee rate and then it sends out that transaction. But the API doesn\u2019t give you a way to say \u201cHey lnd. Generate a transaction to send this amount to this address and give me back the transaction so I can look at it and see how big is the transaction.\u201d It is kind of all or nothing at the moment.\n\nQ - So you want some kind of dry run payment?\n\nA - Yeah exactly. We want a dry run. We want to be able to create a dry run transaction so we can see how big it is. Then we can take a fee estimate and we can apply that and we give the user an option of whether they want next block or next six blocks or whatever. Then we can extrapolate that out and show them the cost that they will actually pay. The best thing you can do currently is say that it is 3 sats per byte and what does that mean?\n\nQ - I\u2019ve done this with an application using bitcoinjs-lib. I think you referenced this also. You can generate your own transaction, count the bytes and then use the fee estimation per kilobyte.\n\nA - But how can you do that if your Bitcoin wallet is running on a remote lnd node? How are you going to generate a transaction from that? You need access to the full node to generate the transaction.\n\nQ - You need to be able to get the UTXO to find the inputs you\u2019re going to spend.\n\nA - That\u2019s it. All we can get is what lnd gives us and it doesn\u2019t unfortunately give us that. Maybe someone knows a way of doing it but we haven\u2019t found a way to do that yet. This PR #1228 is a pull request to expose\u2026 because lnd does have fee estimation inside it and this PR here is looking to expose that as a gRPC endpoint so you can just say \u201cgive me a fee estimate for this transaction.\u201d So that would solve for that.\n\nSo that\u2019s some of the new payment request forms. They\u2019re more interactive now. You can basically paste in an onchain address or an offchain address. It will determine what it is, it will decode the invoice and show the users the details and they can get the fee estimate and hit send. One of the things that I found when building this as well that is kind of interesting is that when you have a payment request we basically want to take that payment request and decode it. What we were doing previously is we were sending that payment request to lnd and having it decode the invoice. It spits out a representation of that invoice data.\n\n## Storybook\n\nAs I started to build this out I took this as an opportunity to do some more refactoring on the app and this snowballed into building out a storybook for our app. If any of you are familiar with React development or that sort of world, storybooks are a tool that allow you to have a catalog of all the React components that we\u2019ve created. We can see how they look, we can interact with them, we can see how they look and feel and how we can build them together. I\u2019ve gone through the app, I\u2019ve extracted all the components and we\u2019ve got a full catalog of all the different bits and pieces. We have everything from the color palettes, the typography that we\u2019re using, the different button states, page layouts that we\u2019re using within the app and things like that. It gives us a catalog of all the different components that we\u2019ve got to build with and we use those to build out new sections of the app. One of the really cool things about the storybook is that this allows us to build stuff without using lnd or even starting up Zap. What I\u2019ve found is that since I\u2019ve built the storybook I probably spend 80% of my time when I\u2019m building stuff on zap-desktop building in the storybook environment just using Chrome, using my web browser. From here we also have full page mockups which you can interact with. What I\u2019ve found was that when we\u2019re building stuff of lnd we\u2019re trying to build a UI for some particular state. For example, let\u2019s say you\u2019re trying to make a payment and it has failed routing. lnd gives you back an error that says \u201crouting failed\u201d and we want to show the user an error explaining to them the routing failed and what they can do about it. In order to build that into the UI that relies on us having lnd running, we\u2019ve got to have lnd synced, we\u2019ve got to have some testnet coins, we\u2019ve got to have some connections to the network. If you want to do that in a real world scenario it is work to get the app into that state so that you can even test that failure case that you\u2019re trying to build for. In the storybook we basically mock and stub the lnd calls\u2026. For example, when you click on something within the storybook, whereas within the app it would actually call into lnd and ask lnd to do something, in the storybook environment because we don\u2019t have lnd running we just call into a mock function. Then we have that function returned back to us the data we\u2019re expecting to see. Either the success case or one of several failure cases. We can simulate in here success and failures of all sorts of different things that lnd might throw at us without even having to have lnd running. This lets us be really productive in terms of building out UI and we can build out new features in here and work with graphic designers to get the UI fine-tuned. Then only at the last minute do we integrate that into the app and start using it with actual lnd. If we\u2019ve done it properly and we\u2019ve mocked out those API results from lnd properly it is pretty straightforward to integrate that. Some of the new stuff we\u2019ve been building, I probably spend 80% of my time in storybook. Then it\u2019s just the last little hurdle to integrate it into the app when you\u2019re actually running the app and connecting to the network. We haven\u2019t done a lot of work with regtest. We haven\u2019t really been using that, we\u2019ve been building against testnet. We could probably simplify some of that or speed up some of that process by not having to wait for things to be mined on testnet.\n\nQ - Bcoin, I think that\u2019s the Javascript Bitcoin library. There is a Bcoin regtest instance in the browser and then maybe a complete lnd node in the browser.\n\nA - In the storybook environment I don\u2019t really want to have anything to do with anything not Javascript. I know Bcoin is a Javascript implementation but it is something that is pretty heavyweight to run in here and would add some complexities. If we\u2019re just basically calling a function that gives us back data instantly, we can craft those to represent what we see lnd typically gives you.\n\nQ - A mock lnd makes more sense\n\nA - We don\u2019t have a full mock lnd implementation. It would be a nice thing to work towards. Currently we just stub the specific requests we\u2019re trying to build against.\n\n## Home\n\nIn the storybook, we\u2019re building out a new feature. It is going through some testing at the moment. What we\u2019ve seen is that lots of people who are using Zap are trying to connect to multiple wallets. Certainly I am as a developer building on it. I have got multiple testnet wallets and mainnet wallets. People have got Litecoin wallets, they\u2019ve got wallets up on BTCPay. If you\u2019re a merchant and you\u2019ve got five stores. With zap-desktop currently you can just connect to one node. When you quit the app you basically start from scratch again. You have to go right through the onboarding process every single time. Here we\u2019re storing the save wallet configurations. You\u2019ve got a top level home area where you can access your different wallets. You only access this section if you need to. If you\u2019re just using one wallet you don\u2019t ever need to see this. When you start up Zap now it will take you to wherever you were last when you quit the app. If you were in your wallet and you quit Zap the next time you start up Zap you\u2019ll be back in your wallet. If your wallet is locked and needs a password to unlock then sure it will allow you to unlock it. We\u2019ve removed some of that friction of having to go through the onboarding process every time. You can have your different save wallet configs and you can tune your settings. It is pretty basic at the moment but it is already useful. You can give your wallet a name for organizational purposes in Zap, you can configure the alias, you can configure autopilot. We\u2019ve actually currently got some of the fine-grained autopilot settings in there. We\u2019re trying to strike a balance between what is useful and what is complex. Are we building for power users or not so technical users? Currently we\u2019re probably building for slightly more technical users because that\u2019s the current user base.\n\n## Lightning Network\n\nI want to finish off with some general challenges and insights I\u2019ve had whilst working through this whole thing. The challenges in terms of the Lightning Network are slow sync times. I talked about that before. If you\u2019re expecting it it is fine. It is fine to start up your app and wait five minutes and have it sync. But it\u2019s not something that you could say is consumer ready. Sync times is a pain and it slows down your development flow as well. If you need to spin up a new node and get it into a ready state you\u2019re going to be waiting some time before you can be productive again. Sync times are painful. The general stability\u2026 I guess I\u2019m talking specifically about lnd because that\u2019s where our focus has been. I can\u2019t really talk to some of the other implementations. The general stability of lnd had been a problem. WIth the latest release, I\u2019m really impressed, it\u2019s really nice to work with. Previously we were getting random seg faults and memory overflows. It would just crash randomly and give us no log output. It was tough to work with and to know what was going on. That\u2019s really improved quite a lot. Upgrading as well between the different versions of lnd. Upgrades of the earlier versions, you might find that a migration script didn\u2019t work properly, you\u2019d end up with a corrupt database. If you\u2019re technical you can probably fix it and get your money back. Now with the latest versions, even with 0.4.2 and the latest 0.5.0 and 0.5.1, these problems seem to have gone away. I would say that particularly in lnd, there is a lot of development happening. It is really fast paced. There are PRs going in all the time. The rate I see stuff going in there makes me question how thoroughly this stuff is being reviewed and how stable is it and are these problems going to start reoccurring. It has definitely improved massively from six months ago when I started working with it. Just keeping up is tough. There is just so much stuff happening. I think Rene is going to be talking about some of the stuff that is going on in the wider ecosystem. Whether you\u2019re talking about splicing or AMP or all these terms that sound really cool and would be interesting. How much time can you dedicate to researching these ideas and actually trying to implement them within your project? You\u2019ve got to pick and choose. Just keeping up with this space is definitely a challenge. On some of these points, the slow sync times are rapidly improving. The general stability is getting better but it is not ready for mainstream because mainstream apps shouldn\u2019t crash. Upgrade pains are getting better. In terms of keeping up, it\u2019s really interesting. If you\u2019re interested in this stuff and you\u2019re looking for something to get involved with, there\u2019s no shortage of problems. Whether you\u2019re a protocol developer or you\u2019re someone like me that is coming from a web development background. I\u2019m not a cryptographer. There\u2019s a lot of different angles you can take with it and that\u2019s kind of cool.\n\n## Ecosystem\n\nIn the ecosystem in general, some documentation issues. We\u2019ve seen incorrect documentation or documentation inconsistencies. Last week or the week before, even within lnd. lnd provides you with a REST API, a gRPC API and a CLI interface. They\u2019re basically all the same thing, they\u2019re just three ways of doing the same thing depending on what you\u2019re trying to accomplish. You\u2019d think if you wanted to run the queryroutes command, it would work the same on CLI versus gRPC but that\u2019s not the case sometimes. I was trying to make a queryroutes call and there\u2019s two things you have to supply. One is the payment request of the invoice you\u2019re trying to pay and the other one is the maximum number of routes you want it to return. With the CLI you just have to provide the invoice and by default it will give you ten routes back. With the gRPC one if you don\u2019t specify how many routes you want to get back, you get an error. When you\u2019re reading the documentation and you think you know how the API works, currently it\u2019s not necessarily the case that if it works that way in one interface that it\u2019s going to work the same way on the other one. You have to cross check these things. Errors and reporting I touched on earlier. The error messages that lnd spits out are very technical. It makes sense because the people that are using lnd are going to be technical. That\u2019s a lower level piece of software that people like us are using to build more high level stuff. The messages that lnd gives out are useful for us but really not helpful for anyone using Zap. We get a lot of questions in Slack, \u201cI\u2019ve got this error when trying to make a payment. What does it mean?\u201d That can be tough. We built a wrapper around the error reporting. We feed errors that we get from lnd into a translation list so we can translate them into something a bit more human friendly. We\u2019ve only covered some of the error messages. As we see these error messages coming up we\u2019re trying to translate them into something that\u2019s a bit more understandable for end users. Some of the tools and libraries, I touched on. Things like seed generation libraries. Where is it? If I want to do BOLT 11 invoice parsing where is it? It\u2019s there. There\u2019s actually a couple of different implementations. One of the challenges with that is that if you give an invoice to lnd and you say \u201cdecode this invoice\u201d it gives you a representation. There\u2019s a Javascript library we\u2019re using called bolt11 and you can give that a payment request and it will decode it. It will give you a representation of the same data but they\u2019re not the same. There\u2019s no standard as to how to display that decoded data or what order things should be in, where they should be. When we\u2019re working in the storybook environment where we\u2019re mocking lnd and we want to be able to take a payment request and decode it without touching lnd, we\u2019re using a different Javascript library that\u2019s giving us different output. Same data but different output format. When we try to integrate with the app we find that there\u2019s some differences and spotting that can be difficult sometimes. The ecosystem is definitely immature. There\u2019s huge scope for tools and libraries. I\u2019ve talked about most of the points here. With the documentation issues, definitely cross check across different implementations. Whether it\u2019s inside lnd itself or whether it\u2019s lnd versus eclair or whatever. For errors and reporting, source code\u2026 Take those error messages, go into GitHub and paste in the error messages and try to find where in the code it\u2019s coming from. At least you can have some context and you can take that into lnd Slack and hopefully somebody there can help you with what\u2019s going on. With the tools and libraries, there\u2019s huge scope for new projects. If anyone is looking for how you can build something that\u2019s useful. There\u2019s a lot of things that you could just build. Little utilities that would just be really useful and would be a good way to make some inroads into building stuff and you can snowball out from there.\n\n## User Experience Challenges\n\nWith user experience, bootstrapping the network is slow, bad user experience. Routing basically doesn\u2019t work, bad user experience. Some of the core concepts within the wallet\u2026 inside Zap you\u2019ve basically got two wallets. You\u2019ve got your onchain balance and then you\u2019ve got a balance that\u2019s in some channels. You\u2019ve got to present the user with these two different balances and help them understand what they mean. If you\u2019ve got money in some channels, you\u2019ve got 0.2 BTC in some channels and 50% of that is in one channel and the other 50% is spread unevenly between six other channels. How do you know what\u2019s the maximum I can send to this person at any point in time? There\u2019s no definitive answer. It depends on when you ask the question and how good your connection is to the network to know how much you can actually send. Trying to decode that and present it to the user in something that they can understand and not be confused by is hard. I don\u2019t think we\u2019ve done it but I think as we iterate on the software we can improve that. It is a real core concept. Channels aren\u2019t going to go away, channel balances aren\u2019t going to go away. Maybe when we\u2019ve got AMP or something like that or we\u2019ve got some kind of automated rebalancing system in place where you can just have the software behind the scenes rebalance everything for you. Then you have one number you can show the user and this is how much you\u2019ve got and how much you can send. Currently that\u2019s not the case. That\u2019s a big user experience challenge. I think the interesting thing here on the bootstrapping the network is that what that says to me is because there\u2019s a real problem with the network bootstrap process, it says to me that the user base currently is technical. If the majority of the people that were using Lightning were non-technical users we\u2019d be hearing about the network bootstrap pains a lot more than we do. The fact that people are using it know that it takes a few minutes to synchronize and that\u2019s expected, it must be the case that most of the people using it are technical currently. With the routing I would just say it is a bit of a concern. I wouldn\u2019t say it is an unsolved problem. I know lots of people are working on different ways to solve this. I think the current solutions are not adequate and they need a lot of work. Until we\u2019ve got 95-99% success rate it is going to be continually presenting problems to users. We\u2019re talking about consumer facing applications, you need something that just doesn\u2019t fail. WIth all of these core concepts like with the wallet balances we just need to keep iterating on the software and keep taking in feedback from our user base. Keep tweaking, keep tuning it until we have something that people can just understand. I think this tells us that when we\u2019re talking about building for power users versus end users, what it tells us is that we\u2019re at real early days. When Jack started the project the goal was to build something that\u2019s for end users and make Lightning simple to use. I think he really succeeded in that before there was Zap the only way you could interact with Lightning was being a techno geek and command lining stuff. We do have applications now that are more end user friendly but the fact is that the vast majority of the user base is technical and so it makes sense at the moment for us to be building for a slightly more technical user base. Things like giving them control over autopilot and their allocations, letting them see the channel management, letting them use those features. We\u2019ve had some people in Slack asking \u201cIs this too complex? How are end users going to use this?\u201d. The answer right now is that they\u2019re not. They\u2019re not the current audience. We\u2019re still building a network, we\u2019re still building the protocol. We can\u2019t really be building for end users yet but we can start that process and that\u2019s what we\u2019re trying to do.\n\n## Next Steps\n\nTo wrap up, I think some of the next things we\u2019re going to do with Zap is we\u2019re going to keep refactoring, keep improving the codebase, keep improving the UI. We\u2019re going to try to fulfill the mission that Jack set out to do which is to make Lightning Network accessible to people. We\u2019d like to do some deeper integration with our mobile wallet for example or with some of these hardware nodes. I haven\u2019t actually used them myself but the Raspiblitz nodes and the Casa nodes and these little hardware Raspberry Pi devices. Some people have built some integrations that allow you to connect Zap really easily but we\u2019d like to get some deeper integration with those tools so that people who are using those nodes have a really easy way to connect their Zap wallet and use that as their remote control. We\u2019d like to get onto looking at channel rebalancing strategies. I\u2019m not too familiar with what\u2019s going on in the space in terms of the lower level, the protocol level. I think that until we start seeing stuff at that level, maybe we can start building something on a slightly higher level to give users some tools to help them rebalance their channels. Maybe that\u2019s a manual process to start with and eventually that can fade away into the background. Then we want to look at some really cool stuff like submarine swaps, the fancy stuff\u2026 For us building on a higher level, we need some of the stuff to be more stable and built into the base protocol before we start using these types of things. We don\u2019t want to be building on new features where the API is going to change out from under us. We do want to keep integrating new cool stuff into the software.\n\n## Resources\n\nI\u2019m just going to leave you with a couple of resources that I think are really useful if you\u2019re in this space, if you\u2019re trying to keep up. The Optech newsletter is weekly, it\u2019s really awesome. It takes you about five minutes to read it. They summarize the key things that are going on in the space. They focus on Bitcoin Core, lnd, eclair and c-lightning and that sort of Bitcoin onchain, offchain crossover. They just pick out some of the key things that have gone on, some of the key developments, some of the key ideas that are coming through. You should definitely subscribe to that if you haven\u2019t already. Lnd Slack, there\u2019s like thousands of people in there talking about lnd and Lightning and asking questions, helping people out. If you\u2019re building stuff you should hang out in there. For us as we\u2019re building closely on top of lnd specifically keeping track of the GitHub milestones gives us a sense of when the next release is going to be, what\u2019s going to be in that release. We can literally see all the stories that are lined up for the next release. We can make sure that what we\u2019re building starts incorporating some of that stuff before it comes into the release and when it\u2019s in the release as well we can start pushing it out to our users. htlc.me is a really cool site. If you just want to generate an invoice and you don\u2019t have lnd running you can just go to htlc.me and you can say \u201cgive me an invoice\u201d and it will give you a Lightning invoice. You can then decode it. If you\u2019re building software on top of Lightning and you don\u2019t want to have a node running so you can get an invoice you can jump over there and it will generate you an invoice. If you want to help out with Zap or you\u2019ve got questions on Zap come and ask us in the Slack. We\u2019re in there 24/7 pretty much. Just to finish up, I would say that if I want you to take something away from this, hopefully I\u2019ve given you a sense on a slightly technical level some of the things that are involved in building out applications of Lightning. If you\u2019ve got some experience with web development or just development then you\u2019re probably qualified to start building stuff in this space. Don\u2019t be scared off by the fact that there is cryptography involved because you can come in at a higher level. You don\u2019t need to be building on the protocol. You can be building.. whether it\u2019s the device that dispenses M&Ms or a software wallet, it\u2019s really just a React Javascript web app that\u2019s making API calls. If you\u2019ve got some development experience you\u2019ve probably got what you need to start building cool stuff on Lightning.\n\n## Q&A\n\nQ - Has anyone worked on c-lightning integration for Zap?\n\nA - Not that I\u2019m aware of, I certainly haven\u2019t. I haven\u2019t seen anything. It does support Litecoin as well, some people made sure that it would work for that.\n\nQ - Is there enough abstraction in there that somebody could even do that? It sounds like there\u2019s a tight coupling with lnd.\n\nA - I\u2019m trying to abstract things out, building out mock interfaces and things like that is a step along that line. Currently we\u2019re pretty tightly coupled but there\u2019s no reason in the future that we couldn\u2019t support c-lightning.\n\nQ - There is a Zap wallet for iOS, a Zap wallet for desktop. What about a Zap wallet for Android? I hear it is almost a web app in a native container deployed to desktop systems. There are also techniques to put this into a mobile container and run this on Android.\n\nA - There are. The lnd team, Lightning Labs, are building out their wallet. I think it is called Lightning App. That is a React app as well, they\u2019re using React native so they have one app that runs in all the different environments: iOS, Android and the desktop. We took a slightly different approach with this. The iOS app is written in Swift and is a native app. There are some inherent advantages with that. We\u2019re focusing on slightly different use cases as well. WIth the desktop app we\u2019re trying to build some slightly more technical tools into it so it\u2019s not like there\u2019s a one-to-one mapping between the functionality we want to provide. In terms of Android, I don\u2019t think anyone on the Zap team uses Android so thus why it hasn\u2019t been built. If someone wants to build it. If there\u2019s enough interest we\u2019ll build it but I haven\u2019t seen that many people ask for it.\n\nQ - So if you want to support the other Lightning implementations I think that would be super useful. There\u2019s already Christian Decker\u2019s Lightning integration repo. He\u2019s already trying to support multiple nodes so he can test channels from c-lightning to lnd and vice versa and all different kinds of implementations. I think it would be so useful to have a proper API that would work against all nodes for doing all these things. All the implementations are supposed to be doing the same thing.\n\nA - That\u2019s right. Under the hood they are compatible with each other at the protocol level. When the app started to be built, lnd seemed to be one of the more popular implementations. I\u2019d say it probably still is but maybe that\u2019s just because I\u2019m in that space. As more and more people start using the different implementations it would be a shame if we\u2019re just tied to lnd and there\u2019s three other implementations and two-thirds of the user base that can\u2019t use Zap because of the particular lnd node instance they\u2019re running. Definitely something I\u2019m keen to look into. In terms of tight coupling, when we were building the BTCPay Server integration, Nicolas wanted to expose the REST API and we wanted to use the gRPC API because that\u2019s how Zap works today. It shouldn\u2019t be too hard to have an abstraction layer within Zap where you can use REST and WebSockets if you want to talk to the REST API or gRPC if you want to use that, you should be able to use both. Currently because Zap evolved out of building for a specific use case there\u2019s a tight coupling with gRPC. There\u2019s nothing in the codebase that would make it difficult to do that, the code that integrates with lnd is in a couple of specific places. There\u2019s not that much we do really. With gRPC, the gRPC gives you an object that you can natively use in Javascript. Currently it\u2019s not done right because we have our own little REST API on top of gRPC and as we communicate between the renderer process and the main process in Electron, we\u2019re basically communicating with the REST API which is then telling gRPC to do stuff. We can definitely change that and there\u2019s not too much code involved to say we could use REST and gRPC. By the same token I don\u2019t think there would be that much involved to say you can use this node implementation or that node implementation. Today it\u2019s not there.\n\nQ - I just wanted to encourage you to make it separate from Zap. Then it could be useful for testing and then you might get other contributors. You might get an interface that supports everything and not just what Zap wants to do. Win-win.\n\nA - Definitely. Everything we do is open source. A lot of it is embedded in Zap at the moment. There are a couple of libraries that we\u2019ve taken out and extracted separately. We have a library called lnd-binary which lets you really easily install lnd. You can do npm install lnd-binary. It will go to GitHub, it will fetch the lnd binary, it\u2019s got a repository of the checksums, it will validate that it\u2019s the right binary and it will extract that and make it available for use in Node. There are things like that where we\u2019re starting to pull out some of that functionality and extract it out into separate libraries. If we get to the point where we\u2019re building an abstraction or an API that can spit out to three different node implementations or however many it would definitely be something that we\u2019d open source outside of the context of Zap.\n\nfollow-up: <https://www.reddit.com/r/lightningnetwork/comments/ba3kac/tom_kirkpatrick_zap_wallet_dev_on_building_lnd/>",
    "url": "https://btctranscripts.com/lightning-hack-day/2018-12-01-tom-kirkpatrick-zap-wallet",
    "tags": [
        "lightning"
    ],
    "body_formatted": "## Introduction\n\nI\u2019m Tom. I\u2019ve been working on the Zap desktop wallet for the last six months or so. If you\u2019re not familiar, we\u2019re trying to build consumer facing Lightning applications. We\u2019ve currently got an iOS app and a desktop wallet. They\u2019re pretty similar, the interface is pretty similar between them but they\u2019ve got a slightly different focus. I\u2019ve been working on the desktop wallet. Can I just get an idea of how many people here have used Zap? Quite a lot. That\u2019s probably about 80-90%, that\u2019s awesome.\n\n## Overview\n\nI want to take you through a couple of different things. First I want to talk about my experience of building on Lightning and what I found is involved in that. Then I\u2019m going to take a look under the hood of Zap. I\u2019m going to get a little technical but I\u2019m not going to be showing code samples or anything like that. I want to give you a sense of how it\u2019s interacting with Lightning and what the communication stream is like and what we\u2019re doing underneath the interface that you guys see. I\u2019m going to show you some of the new features and things we\u2019ve been working on. I\u2019m going to touch on some of the challenges that I\u2019ve faced and some of the insights that I\u2019ve got from working on this stuff over the last few months.\n\n## Basically a web app\n\nSo starting off, building on Lightning. The first thing I would say is that it is basically a web app at its core. Technically it is a React application and it is running in Electron. If you\u2019ve done web development before and you\u2019re familiar with client-server architecture it is pretty similar. When you\u2019re building websites you\u2019re maybe using Stripe API or PayPal API to make payments, we\u2019re just using lnd under the hood. Everything you\u2019re doing in the interface is literally sending messages over to lnd and lnd is doing all the interfacing with the Lightning Network. We\u2019re getting realtime data back from lnd and we\u2019re presenting that and allowing people to interact with the network without really knowing that\u2019s what they\u2019re doing. The tools and processes that we\u2019re using to build out the app are really similar to if you\u2019ve done any web development. It\u2019s literally a Javascript application. You guys will probably be familiar with that sort of thing. We\u2019re running continuous integration with Travis and AppVeyor. We\u2019re using Jest for our automated testing. We have a pretty much zero touch deployment process whereby when we commit everything to GitHub, every commit triggers a build which triggers the test suite which triggers packaging up the application into the Electron package. That gets uploaded to GitHub. We always have the latest version of Zap available on GitHub for download. We actually just publish, when we\u2019re ready to do a release, we publish the most recent version. We\u2019ve always got those builds available in the background.\n\n## The 1000\u2019 view\n\nEssentially it is really just a wrapper around lnd. We\u2019ve built into it support for running lnd locally on your machine so you can run lnd on here via zap-desktop. You can also connect it to a remote node as well. In both cases it is just working as a remote control. The difference is that when you\u2019re running lnd locally you\u2019re communicating with gRPC locally on that node. We basically have two different Javascript processes running. We have the browser environment which is basically a Chromium environment that runs inside Electron. That\u2019s giving the browser window, essentially what you\u2019re seeing is a web browser with the React application running in it. We\u2019ve got lnd running in the background and we\u2019re using the gRPC API to communicate between the two. Because we\u2019re managing lnd as an external process so we have the lnd binary packaged up in that Electron app, we literally use Node spawn so we have full Node.js facilities within there. We use Node, we spawn that process. We have a finite state machine that sits on top of that lnd process so that we can more easily manage transitioning it from one state to another. When we\u2026  the app we set the state machine in a ready state and then when you access a wallet we transition to a running state as we start the process. We attach some event listeners to the lnd log output and we monitor the process. We can stop it and restart it and things like that. We\u2019ve also got some supporting infrastructure, more backend stuff. Specifically we have a cluster of btcd nodes which are our Bitcoin full nodes. If anyone is not familiar with btcd, it is a full node implementation similar to Bitcoin Core. We have a few instances of that running. We currently run them on the Google Cloud environment so we have Docker containers. If you go to our GitHub we\u2019ve got two different Docker containers. We\u2019ve got a lnd one and a btcd one. We use Kubernetes to deploy those out to Google Cloud. The actual full blockchain data is stored in Google persistent drives which we attach the stateful drives to the node instances up on Google Cloud. We have those because when you\u2019re running lnd locally on the machine, lnd connects to our btcd nodes. It connects to a couple of them in parallel and it synchronizes the blockchain data from those nodes. If you\u2019re using the remote node it doesn\u2019t touch our btcd nodes at all because you\u2019re connecting to your own setup where you\u2019ve got your own full node.\n\n## Bootstrapping\n\nDiving a little further under the hood. When you start the app, the first thing we do is we go through some sanity checks. We check the filesystem, we check that your wallet is aware. We expect it to be so when we start lnd we create a wallet which creates a lnd directory in a specific location. It actually gets stored in the user data directory from Electron. It will be in a slightly different place depending on which environment you\u2019re running on, Mac or Windows or whatever. It\u2019s essentially application state data. We also use IndexedDB. Within the Electron browser environment we\u2019re using IndexedDB which is a native browser based database. In that we store some persistent data. We don\u2019t store a lot but we store your wallet configuration. When you spin up a remote connection you\u2019ve got to tell lnd where\u2019s your macaroon, where\u2019s your certificate, things like that. That configuration we store in IndexedDB. We store some user preference data, what theme you\u2019re using whether it is the light theme or the dark theme. What language you\u2019re using or what currency you\u2019ve selected. There\u2019s only a small amount of data that we\u2019re using currently. Previously we were using files on the filesystem, we had a JSON file with a little bit of config in there. We found that as we started to build it out more we needed something with a bit more of a rich API than just accessing a file. IndexedDB is really lightweight and built into the Chromium environment so we\u2019re using that for our persistent data. As we start to build things out more there are probably some nice things we can do by having access to that database.\n\n## Onboarding\n\nThe next thing once we\u2019ve booted up the app is we send the user into this onboarding process. I think this screen embodies what we\u2019re trying to do with Zap which is providing something simple and easy for end users who aren\u2019t so technical. I think we\u2019re partly the way there. There are a lot of things that can be done to continue to make it more user friendly. There are a couple of basic options whether you want to create a wallet, import a wallet or connect to a remote node. We have a form wizard to collect up that data. We collect up the data, we store it in Redux within React. We store that data in Redux which is the persistent data in the browser while we\u2019re going through this process. Once we get through this process, we spawn the lnd. If you choose to select the local node\u2026 this is where we start to spin up lnd. We spawn a lnd process which basically gets gRPC running up on port\u2026 We actually select a random port. It will be somewhere around the 10009 range which is the default port. We have a range of ports that we use. We scan for a free port, start up lnd which gives us that gRPC interface. We make an API call into it and we tell it to generate a seed. We spit that back to the renderer process and we present that on the screen for the user and obviously ask them to write it down. Then we actually kill that lnd process. That is a new thing we\u2019ve started doing because some of the stuff I\u2019ll show you in a bit, some of the new stuff, you can move in and out of this part of the app. It is something I\u2019ve been working on recently. I\u2019m really interested if someone has a better way of doing this. If we just want to generate a seed, spinning up a binary process and getting access to an API and connecting to gRPC and making an API call, it seems like overkill just to generate a seed. If there was a native Javascript library we could use\u2026\n\nQ - There\u2019s a BIP 39 Javascript library. BitcoinJS can probably do it or the other one?\n\nA - The seed format is slightly different for lnd I believe. They have an aezeed. It\u2019s not standard BIP 39. These things will come\n\nQ - Then you\u2019re out of luck. It\u2019s probably just one little Go file that maybe could be converted to Javascript. To WebAssembly? That\u2019s a bit overkill maybe too but sounds like fun.\n\nA - If someone wants to pick it up we\u2019ll happily accept it.\n\nThat\u2019s what is happening here. You\u2019re connecting to a remote server. Currently it works and is functional. We get a lot of support requests in Slack for people trying to figure out how to do this. If you ever try to connect to a remote node you\u2019ve got to get three key pieces of information. You need to know the hostname and the IP address of the machine where lnd is running. You need to know the port where lnd is running. You need to get a TLS certificate and an admin macaroon file from that server. You need to copy those to your machine and you need to tell Zap where those files are. Even in saying that you can hear the friction that is involved in that. We\u2019re trying to build something that is consumer facing, that\u2019s an easy to use Lightning wallet. It\u2019s really not easy to use.\n\nQ - If it runs on your own machine, I assume these are all\u2026\n\nA - This is the point. This is the case where you are connecting to a remote node. Imagine you\u2019ve got a piece of hardware at home that is running a full node for you and from your laptop wherever you are, you just want to be able to connect to that. Or you\u2019ve got a BTCPay Server instance or anywhere where you\u2019ve got a remote node. In order to do this you need to shell into that node. You need to navigate into the lnd directory. You need to find these two specific files. You\u2019ve got to copy them over to your local machine. You\u2019ve now got to store them somewhere on your local machine. You\u2019ve got to enter in the path to where they are. We could have a button where you click browse and you could navigate to the file. You can see the friction in that. Also that\u2019s inherently insecure because if you think about it if you\u2019ve got those files:  the TLS file and the admin macaroon, you basically have full control over that Lightning node. Whoever has those files can control the node. They are your keys essentially in a sense. We\u2019re asking users to copy them across a network and that\u2019s going to be pretty insecure in most situations and we\u2019re asking people to store them somewhere. Where do they put them? There\u2019s no standard place. This is the current situation and there are definitely things we can do to try to improve that process.\n\nQ - The whole point of macaroons is that you can give partial permissions? The lnd server itself should be able to generate some thing that you download or some QR code?\n\nA - It can. But in order to have a wallet like Zap you need a macaroon file which gives you permission to send money. Anyone who has got that macaroon now has permission to send money. There\u2019s no way around that. If you want a wallet you\u2019ve got to be able to send right? It is the most basic functionality.\n\nQ - Why are you saving them as files?\n\nA - That\u2019s what we do currently. We can certainly use the operating system\u2019s private store which would be a better solution. But the user has also still got to get that data to us somehow. We could rather than ask you to enter in a path to a file, we could have somewhere they just paste in something. It gets a little more complex because the macaroon is actually a binary file so you can\u2019t copy and paste binary data into a field in a web browser. You can base64 encode it. This library here zapconnect is a library we wrote to help this process. zapconnect is a little Go application that\u2019s compiled into a binary. You can install zapconnect on your lnd node where lnd is running. When you run zapconnect it will generate a QR code for you that is a representation of the macaroon, the certificate and the connection: the hostname, port, all these bits of information. They\u2019re encoded in the QR code. With the iOS app you can just scan that. In the iOS app it is pretty frictionless. You install zapconnect on your Lightning node, you run zapconnect, you get a QR code and you go connect with your phone and you just scan it.\n\nQ - How do they do hole punching on iOS because you have to have an open port? We had this problem in the 90s, it resurfaces\u2026\n\nA - It\u2019s another of the questions we get all the time in Slack. There are a few different pitfalls here. One is people have got to open up their port. They\u2019ve got to make sure their firewall is forwarding packets. It is definitely fraught with difficulty.\n\nQ - I don\u2019t know if macaroons support this but what you could do is generate a private key on the desktop app and then give the public key to the lnd server and then make it generate a macaroon that says only the signer of this public key can communicate with me. At least then you\u2019re not sending any private keys over the wire, just public keys.\n\nA - That\u2019s an interesting idea.\n\nSo that connect works really well with the mobile app. There\u2019s two ways you can run it. You can generate a QR code. You can also generate a JSON snippet as well which you can copy and paste. That JSON snippet contains the macaroon in it as well. That\u2019s a really interesting idea, maybe we can chat about that afterwards.\n\nQ - I read the macaroon paper like ten years ago so don\u2019t interrogate me on it but I remember that they said you can have your Flickr photo album and then you can give somebody a macaroon that\u2019s as if you\u2019re logged in with your Yahoo account or your mom\u2019s account. They had some fancy ideas about permissions to solve this type of problem.\n\n## BTCPay Server\n\nOne of the final things that we built into the app in terms of connectivity is we built an integration with BTCPay Server. This is another way around this issue. We worked with Nicolas who is the developer of BTCPay Server to build out this configuration format. He now has in BTCPay\u2026 BTCPay is like a store that merchants can use to really easily spin up a Lightning node and have a store and point-of-sale device and things like that. We\u2019re seeing a lot of merchants using that. In BTCPay you can go in and say \u201cshow me my connection string\u201d. It will show you a QR code or something that you can copy and paste. You can just copy that, paste it directly into here and hit next and you\u2019re done. It\u2019s a bit more frictionless but that only works because on BTCPay they\u2019ve already got the infrastructure to generate this\u2026 It\u2019s basically doing what the zapconnect library is doing, something very similar, generating something that you can copy and paste over.\n\n## Syncing\n\nSo once you\u2019ve made your connection the next thing we do is we start synchronizing. If you\u2019re running lnd locally then we go into lnd synchronization process. It is something that was really tricky to build. Our implementation of this is hacky to say the best. The problem is that with lnd you\u2019ve got no idea how far through the synchronization process it really is. The way that we do this is we attach a listener. We\u2019ve got the lnd process running locally on the machine and we attach a listener to the standard output and the standard error of the lnd process. We run regex on every single line of log output and we\u2019re basically listening out for things that give us some kind of hints on what\u2019s happening in the sync process. We\u2019ve got a list of probably 15 or 20 log messages that we know are interesting to us and give us a hint as to whether a new block header has just been downloaded or some commitment filters have been downloaded. It would be nice if lnd had a stream that you could just connect to. lnd has bidirectional streaming like WebSockets where you can get data fed to you in realtime. They have it for some stuff like transactions and invoices and channel data I think you can get data to stream for you. You can\u2019t get any of this state data streamed to you currently. PR 1355 is trying to build support for Prometheus which is a monitoring system which allows you to tap in and get all kinds of metrics from lnd about memory usage. I think they are talking about including things like sync data and stuff like that. If there was something like that and that was exposed over the gRPC interface we\u2019d get a lot more insights into what\u2019s going on in lnd. At the moment it is pretty rudimentary and it\u2019s limited because we can only do that on a local process we\u2019re running. If we\u2019ve connected to a remote node we\u2019ve got no way of knowing what\u2019s going on in that. lnd has an API call that\u2019s called getinfo and when you run that it has a flag in there that says \u201csynced to chain\u201d. It\u2019s true or it\u2019s false. When the synchronization process takes several minutes you need to give the user some feedback as to what is going on. Another shortcoming that we found as well is that even just knowing what the current block height is, what\u2019s the latest block on the blockchain, what\u2019s the current block height number? When you connect to lnd and it starts synchronizing, lnd will tell you what it thinks is the latest block. It will tell you the latest block that it has. But if lnd itself is still in the process of synchronizing with the blockchain, the latest block that it has might not be the actual latest block. So we have to make a call out to a block explorer. I think we use blockchain.info and we figure out what the latest block is so we can show the progress incrementing. Even that is fraught with challenges because we found cases where blockchain.info would go down. So we actually now make three different API calls out to three separate block explorers. Whichever one gives us a result back first we use that to assume that\u2019s the current block height and we start pulling\u2026\n\nQ - Why are you not just pinging the full node?\n\nA - We don\u2019t have access to the full node. We\u2019re only connected directly to lnd and lnd might be talking to a full node that\u2019s on a different machine somewhere.\n\nQ - lnd cannot relay that? It sounds like a simple pull request\n\nA - When we\u2019re running lnd on here, we\u2019re running it in Neutrino mode and that\u2019s basically talking to our btcd servers.\n\nQ - You said you had several btcd running on Google Cloud. You can connect to those?\n\nA - Yeah we can. There are different places we can get that data from but it would be nice if lnd\u2026 Because lnd is our primary interface for everything Lightning we can do 90% of stuff but it\u2019s that extra 10% where we have to figure out workarounds whether it\u2019s calling btcd\u2026\n\nQ - Where is the Neutrino protocol coming in? The lnd node on your local machine is connected through Neutrino to the rest of the Bitcoin network?\n\nA - When you\u2019re running it locally you\u2019re running lnd locally and lnd is running as a Neutrino client which is connected to our btcd full nodes. Neutrino is the light client implementation between lnd and the full nodes.\n\nQ - Can lnd also be run with a local full node? It doesn\u2019t use any of the Neutrino stuff?\n\nA - That\u2019s right but we don\u2019t want to be downloading gigabytes of data. When you use Neutrino with testnet, most of my lnd directories are 400MB or something like that. You can download that pretty quickly. This currently takes about 5 minutes on testnet. If I\u2019d have done this a couple of months ago that would have taken about 15 minutes. There\u2019s a lot of improvements coming. What they\u2019ve done is they\u2019ve now made it so that Neutrino can pull the block headers and the commitment filters in parallel and it can pull them from multiple btcd nodes at the same time. So we\u2019re getting 4x what we used to get. They\u2019re starting to work more actively on the Neutrino support so I think there will be some more improvements. That\u2019s testnet as well so mainnet is much smaller and would be faster again.\n\n## Wallet\n\nAnother thing to point out here is that on the right you\u2019ve got the channel management piece. The idea here is that once lnd has built up a picture of the network which as I said can take some time, then you can go and start establishing channels with nodes. If you turn on autopilot it will do it for you. By default we have it set, I think we just use the lnd defaults which allocate 60% of your funds over a maximum of 5 channels or something like that. It should theoretically give you a good route into the network but in practice that doesn\u2019t really happen at the moment. The channel management piece - you can click on one of these channels and you can see how much balance is in each channel and things like that. Ultimately we\u2019d like that to disappear into the background. Maybe we can collapse it or something. Maybe eventually we can hide it away in an advanced settings page. Currently there\u2019s literally no way you can use the wallet without being able to inspect your channels and manage them manually. That speaks to a bigger point which is it is difficult for you to use the wallet without knowing actually what a channel is. We\u2019re talking about building things for mainstream. If you need to know what channels are we\u2019re not there yet.\n\n## Pay / Request\n\nI wanted to show you a couple of new bits and pieces that we\u2019ve been working on. Some of this is already in the master branch, some of this is going through review at the moment. The first thing is the payment and the request forms, if you\u2019re familiar with Zap currently you might see some differences here. We started building out support for fee estimation which we can get about 50% of the way there currently. In terms of making offchain payments like Lightning payments what we do is we send the payment request to lnd, we use the queryroutes API call. We ask lnd to give us a list of up to ten routes and it will return those to us in order of lowest fee to highest fee. We can then present the user with the lowest fee that we\u2019ve got and the highest fee that we\u2019ve got. We give them the range of what we think it is going to be. When they hit send and we send the payment we take the maximum fee that we got from our list of ten routes and we apply that as a fee limit. In the current version of Zap that you guys might have, when you actually send the payment we just blindly spit it out to the network. If it finds a route it will send on that route regardless of what the fee is. Here we\u2019re showing the user upfront what\u2019s the possible range. We generally see that this is between 1 and 3 satoshis, something like that. They\u2019re pretty low but it is important if we\u2019re showing the user it is between 1 and 3 satoshis, we\u2019ve got to cap it at 3. When we make the sendpayment call into lnd we tell it the maximum fee that we\u2019re going to apply which is the highest of the fees that we got back from queryroutes. If it manages to send it over one of those ten routes then fine. When you tell lnd to send a payment it will keep trying routes until it finds one that works or it times out. So we make sure we put in a hard stop in if the fee limit has been reached. In terms of the onchain fees we\u2019ve had some challenges here because lnd doesn\u2019t currently provide a fee estimation interface on REST or gRPC or whatever. So there is no way for us to know upfront what transaction fee is going to be applied. More specifically what we do currently in this latest implementation is we call out to 21\u2019s fee estimation API. We find out what the current estimated fee is to get something in within a few blocks. We can get that per byte fee rate whether it is 5 satoshis per byte or something like that. We can find out what that is but what we can\u2019t do is generate the transaction upfront. We can\u2019t know how big the transaction is going to be and therefore how much the satoshi per byte fee extrapolates out to the full cost of the transaction.\n\nQ - Why can\u2019t you know the size of the transaction?\n\nA - Because lnd doesn\u2019t let you create a transaction upfront currently. With lnd you can just say \u201cmake payment\u201d. Inside lnd it creates the transaction, it does the fee estimation, it applies the fee rate and then it sends out that transaction. But the API doesn\u2019t give you a way to say \u201cHey lnd. Generate a transaction to send this amount to this address and give me back the transaction so I can look at it and see how big is the transaction.\u201d It is kind of all or nothing at the moment.\n\nQ - So you want some kind of dry run payment?\n\nA - Yeah exactly. We want a dry run. We want to be able to create a dry run transaction so we can see how big it is. Then we can take a fee estimate and we can apply that and we give the user an option of whether they want next block or next six blocks or whatever. Then we can extrapolate that out and show them the cost that they will actually pay. The best thing you can do currently is say that it is 3 sats per byte and what does that mean?\n\nQ - I\u2019ve done this with an application using bitcoinjs-lib. I think you referenced this also. You can generate your own transaction, count the bytes and then use the fee estimation per kilobyte.\n\nA - But how can you do that if your Bitcoin wallet is running on a remote lnd node? How are you going to generate a transaction from that? You need access to the full node to generate the transaction.\n\nQ - You need to be able to get the UTXO to find the inputs you\u2019re going to spend.\n\nA - That\u2019s it. All we can get is what lnd gives us and it doesn\u2019t unfortunately give us that. Maybe someone knows a way of doing it but we haven\u2019t found a way to do that yet. This PR #1228 is a pull request to expose\u2026 because lnd does have fee estimation inside it and this PR here is looking to expose that as a gRPC endpoint so you can just say \u201cgive me a fee estimate for this transaction.\u201d So that would solve for that.\n\nSo that\u2019s some of the new payment request forms. They\u2019re more interactive now. You can basically paste in an onchain address or an offchain address. It will determine what it is, it will decode the invoice and show the users the details and they can get the fee estimate and hit send. One of the things that I found when building this as well that is kind of interesting is that when you have a payment request we basically want to take that payment request and decode it. What we were doing previously is we were sending that payment request to lnd and having it decode the invoice. It spits out a representation of that invoice data.\n\n## Storybook\n\nAs I started to build this out I took this as an opportunity to do some more refactoring on the app and this snowballed into building out a storybook for our app. If any of you are familiar with React development or that sort of world, storybooks are a tool that allow you to have a catalog of all the React components that we\u2019ve created. We can see how they look, we can interact with them, we can see how they look and feel and how we can build them together. I\u2019ve gone through the app, I\u2019ve extracted all the components and we\u2019ve got a full catalog of all the different bits and pieces. We have everything from the color palettes, the typography that we\u2019re using, the different button states, page layouts that we\u2019re using within the app and things like that. It gives us a catalog of all the different components that we\u2019ve got to build with and we use those to build out new sections of the app. One of the really cool things about the storybook is that this allows us to build stuff without using lnd or even starting up Zap. What I\u2019ve found is that since I\u2019ve built the storybook I probably spend 80% of my time when I\u2019m building stuff on zap-desktop building in the storybook environment just using Chrome, using my web browser. From here we also have full page mockups which you can interact with. What I\u2019ve found was that when we\u2019re building stuff of lnd we\u2019re trying to build a UI for some particular state. For example, let\u2019s say you\u2019re trying to make a payment and it has failed routing. lnd gives you back an error that says \u201crouting failed\u201d and we want to show the user an error explaining to them the routing failed and what they can do about it. In order to build that into the UI that relies on us having lnd running, we\u2019ve got to have lnd synced, we\u2019ve got to have some testnet coins, we\u2019ve got to have some connections to the network. If you want to do that in a real world scenario it is work to get the app into that state so that you can even test that failure case that you\u2019re trying to build for. In the storybook we basically mock and stub the lnd calls\u2026. For example, when you click on something within the storybook, whereas within the app it would actually call into lnd and ask lnd to do something, in the storybook environment because we don\u2019t have lnd running we just call into a mock function. Then we have that function returned back to us the data we\u2019re expecting to see. Either the success case or one of several failure cases. We can simulate in here success and failures of all sorts of different things that lnd might throw at us without even having to have lnd running. This lets us be really productive in terms of building out UI and we can build out new features in here and work with graphic designers to get the UI fine-tuned. Then only at the last minute do we integrate that into the app and start using it with actual lnd. If we\u2019ve done it properly and we\u2019ve mocked out those API results from lnd properly it is pretty straightforward to integrate that. Some of the new stuff we\u2019ve been building, I probably spend 80% of my time in storybook. Then it\u2019s just the last little hurdle to integrate it into the app when you\u2019re actually running the app and connecting to the network. We haven\u2019t done a lot of work with regtest. We haven\u2019t really been using that, we\u2019ve been building against testnet. We could probably simplify some of that or speed up some of that process by not having to wait for things to be mined on testnet.\n\nQ - Bcoin, I think that\u2019s the Javascript Bitcoin library. There is a Bcoin regtest instance in the browser and then maybe a complete lnd node in the browser.\n\nA - In the storybook environment I don\u2019t really want to have anything to do with anything not Javascript. I know Bcoin is a Javascript implementation but it is something that is pretty heavyweight to run in here and would add some complexities. If we\u2019re just basically calling a function that gives us back data instantly, we can craft those to represent what we see lnd typically gives you.\n\nQ - A mock lnd makes more sense\n\nA - We don\u2019t have a full mock lnd implementation. It would be a nice thing to work towards. Currently we just stub the specific requests we\u2019re trying to build against.\n\n## Home\n\nIn the storybook, we\u2019re building out a new feature. It is going through some testing at the moment. What we\u2019ve seen is that lots of people who are using Zap are trying to connect to multiple wallets. Certainly I am as a developer building on it. I have got multiple testnet wallets and mainnet wallets. People have got Litecoin wallets, they\u2019ve got wallets up on BTCPay. If you\u2019re a merchant and you\u2019ve got five stores. With zap-desktop currently you can just connect to one node. When you quit the app you basically start from scratch again. You have to go right through the onboarding process every single time. Here we\u2019re storing the save wallet configurations. You\u2019ve got a top level home area where you can access your different wallets. You only access this section if you need to. If you\u2019re just using one wallet you don\u2019t ever need to see this. When you start up Zap now it will take you to wherever you were last when you quit the app. If you were in your wallet and you quit Zap the next time you start up Zap you\u2019ll be back in your wallet. If your wallet is locked and needs a password to unlock then sure it will allow you to unlock it. We\u2019ve removed some of that friction of having to go through the onboarding process every time. You can have your different save wallet configs and you can tune your settings. It is pretty basic at the moment but it is already useful. You can give your wallet a name for organizational purposes in Zap, you can configure the alias, you can configure autopilot. We\u2019ve actually currently got some of the fine-grained autopilot settings in there. We\u2019re trying to strike a balance between what is useful and what is complex. Are we building for power users or not so technical users? Currently we\u2019re probably building for slightly more technical users because that\u2019s the current user base.\n\n## Lightning Network\n\nI want to finish off with some general challenges and insights I\u2019ve had whilst working through this whole thing. The challenges in terms of the Lightning Network are slow sync times. I talked about that before. If you\u2019re expecting it it is fine. It is fine to start up your app and wait five minutes and have it sync. But it\u2019s not something that you could say is consumer ready. Sync times is a pain and it slows down your development flow as well. If you need to spin up a new node and get it into a ready state you\u2019re going to be waiting some time before you can be productive again. Sync times are painful. The general stability\u2026 I guess I\u2019m talking specifically about lnd because that\u2019s where our focus has been. I can\u2019t really talk to some of the other implementations. The general stability of lnd had been a problem. WIth the latest release, I\u2019m really impressed, it\u2019s really nice to work with. Previously we were getting random seg faults and memory overflows. It would just crash randomly and give us no log output. It was tough to work with and to know what was going on. That\u2019s really improved quite a lot. Upgrading as well between the different versions of lnd. Upgrades of the earlier versions, you might find that a migration script didn\u2019t work properly, you\u2019d end up with a corrupt database. If you\u2019re technical you can probably fix it and get your money back. Now with the latest versions, even with 0.4.2 and the latest 0.5.0 and 0.5.1, these problems seem to have gone away. I would say that particularly in lnd, there is a lot of development happening. It is really fast paced. There are PRs going in all the time. The rate I see stuff going in there makes me question how thoroughly this stuff is being reviewed and how stable is it and are these problems going to start reoccurring. It has definitely improved massively from six months ago when I started working with it. Just keeping up is tough. There is just so much stuff happening. I think Rene is going to be talking about some of the stuff that is going on in the wider ecosystem. Whether you\u2019re talking about splicing or AMP or all these terms that sound really cool and would be interesting. How much time can you dedicate to researching these ideas and actually trying to implement them within your project? You\u2019ve got to pick and choose. Just keeping up with this space is definitely a challenge. On some of these points, the slow sync times are rapidly improving. The general stability is getting better but it is not ready for mainstream because mainstream apps shouldn\u2019t crash. Upgrade pains are getting better. In terms of keeping up, it\u2019s really interesting. If you\u2019re interested in this stuff and you\u2019re looking for something to get involved with, there\u2019s no shortage of problems. Whether you\u2019re a protocol developer or you\u2019re someone like me that is coming from a web development background. I\u2019m not a cryptographer. There\u2019s a lot of different angles you can take with it and that\u2019s kind of cool.\n\n## Ecosystem\n\nIn the ecosystem in general, some documentation issues. We\u2019ve seen incorrect documentation or documentation inconsistencies. Last week or the week before, even within lnd. lnd provides you with a REST API, a gRPC API and a CLI interface. They\u2019re basically all the same thing, they\u2019re just three ways of doing the same thing depending on what you\u2019re trying to accomplish. You\u2019d think if you wanted to run the queryroutes command, it would work the same on CLI versus gRPC but that\u2019s not the case sometimes. I was trying to make a queryroutes call and there\u2019s two things you have to supply. One is the payment request of the invoice you\u2019re trying to pay and the other one is the maximum number of routes you want it to return. With the CLI you just have to provide the invoice and by default it will give you ten routes back. With the gRPC one if you don\u2019t specify how many routes you want to get back, you get an error. When you\u2019re reading the documentation and you think you know how the API works, currently it\u2019s not necessarily the case that if it works that way in one interface that it\u2019s going to work the same way on the other one. You have to cross check these things. Errors and reporting I touched on earlier. The error messages that lnd spits out are very technical. It makes sense because the people that are using lnd are going to be technical. That\u2019s a lower level piece of software that people like us are using to build more high level stuff. The messages that lnd gives out are useful for us but really not helpful for anyone using Zap. We get a lot of questions in Slack, \u201cI\u2019ve got this error when trying to make a payment. What does it mean?\u201d That can be tough. We built a wrapper around the error reporting. We feed errors that we get from lnd into a translation list so we can translate them into something a bit more human friendly. We\u2019ve only covered some of the error messages. As we see these error messages coming up we\u2019re trying to translate them into something that\u2019s a bit more understandable for end users. Some of the tools and libraries, I touched on. Things like seed generation libraries. Where is it? If I want to do BOLT 11 invoice parsing where is it? It\u2019s there. There\u2019s actually a couple of different implementations. One of the challenges with that is that if you give an invoice to lnd and you say \u201cdecode this invoice\u201d it gives you a representation. There\u2019s a Javascript library we\u2019re using called bolt11 and you can give that a payment request and it will decode it. It will give you a representation of the same data but they\u2019re not the same. There\u2019s no standard as to how to display that decoded data or what order things should be in, where they should be. When we\u2019re working in the storybook environment where we\u2019re mocking lnd and we want to be able to take a payment request and decode it without touching lnd, we\u2019re using a different Javascript library that\u2019s giving us different output. Same data but different output format. When we try to integrate with the app we find that there\u2019s some differences and spotting that can be difficult sometimes. The ecosystem is definitely immature. There\u2019s huge scope for tools and libraries. I\u2019ve talked about most of the points here. With the documentation issues, definitely cross check across different implementations. Whether it\u2019s inside lnd itself or whether it\u2019s lnd versus eclair or whatever. For errors and reporting, source code\u2026 Take those error messages, go into GitHub and paste in the error messages and try to find where in the code it\u2019s coming from. At least you can have some context and you can take that into lnd Slack and hopefully somebody there can help you with what\u2019s going on. With the tools and libraries, there\u2019s huge scope for new projects. If anyone is looking for how you can build something that\u2019s useful. There\u2019s a lot of things that you could just build. Little utilities that would just be really useful and would be a good way to make some inroads into building stuff and you can snowball out from there.\n\n## User Experience Challenges\n\nWith user experience, bootstrapping the network is slow, bad user experience. Routing basically doesn\u2019t work, bad user experience. Some of the core concepts within the wallet\u2026 inside Zap you\u2019ve basically got two wallets. You\u2019ve got your onchain balance and then you\u2019ve got a balance that\u2019s in some channels. You\u2019ve got to present the user with these two different balances and help them understand what they mean. If you\u2019ve got money in some channels, you\u2019ve got 0.2 BTC in some channels and 50% of that is in one channel and the other 50% is spread unevenly between six other channels. How do you know what\u2019s the maximum I can send to this person at any point in time? There\u2019s no definitive answer. It depends on when you ask the question and how good your connection is to the network to know how much you can actually send. Trying to decode that and present it to the user in something that they can understand and not be confused by is hard. I don\u2019t think we\u2019ve done it but I think as we iterate on the software we can improve that. It is a real core concept. Channels aren\u2019t going to go away, channel balances aren\u2019t going to go away. Maybe when we\u2019ve got AMP or something like that or we\u2019ve got some kind of automated rebalancing system in place where you can just have the software behind the scenes rebalance everything for you. Then you have one number you can show the user and this is how much you\u2019ve got and how much you can send. Currently that\u2019s not the case. That\u2019s a big user experience challenge. I think the interesting thing here on the bootstrapping the network is that what that says to me is because there\u2019s a real problem with the network bootstrap process, it says to me that the user base currently is technical. If the majority of the people that were using Lightning were non-technical users we\u2019d be hearing about the network bootstrap pains a lot more than we do. The fact that people are using it know that it takes a few minutes to synchronize and that\u2019s expected, it must be the case that most of the people using it are technical currently. With the routing I would just say it is a bit of a concern. I wouldn\u2019t say it is an unsolved problem. I know lots of people are working on different ways to solve this. I think the current solutions are not adequate and they need a lot of work. Until we\u2019ve got 95-99% success rate it is going to be continually presenting problems to users. We\u2019re talking about consumer facing applications, you need something that just doesn\u2019t fail. WIth all of these core concepts like with the wallet balances we just need to keep iterating on the software and keep taking in feedback from our user base. Keep tweaking, keep tuning it until we have something that people can just understand. I think this tells us that when we\u2019re talking about building for power users versus end users, what it tells us is that we\u2019re at real early days. When Jack started the project the goal was to build something that\u2019s for end users and make Lightning simple to use. I think he really succeeded in that before there was Zap the only way you could interact with Lightning was being a techno geek and command lining stuff. We do have applications now that are more end user friendly but the fact is that the vast majority of the user base is technical and so it makes sense at the moment for us to be building for a slightly more technical user base. Things like giving them control over autopilot and their allocations, letting them see the channel management, letting them use those features. We\u2019ve had some people in Slack asking \u201cIs this too complex? How are end users going to use this?\u201d. The answer right now is that they\u2019re not. They\u2019re not the current audience. We\u2019re still building a network, we\u2019re still building the protocol. We can\u2019t really be building for end users yet but we can start that process and that\u2019s what we\u2019re trying to do.\n\n## Next Steps\n\nTo wrap up, I think some of the next things we\u2019re going to do with Zap is we\u2019re going to keep refactoring, keep improving the codebase, keep improving the UI. We\u2019re going to try to fulfill the mission that Jack set out to do which is to make Lightning Network accessible to people. We\u2019d like to do some deeper integration with our mobile wallet for example or with some of these hardware nodes. I haven\u2019t actually used them myself but the Raspiblitz nodes and the Casa nodes and these little hardware Raspberry Pi devices. Some people have built some integrations that allow you to connect Zap really easily but we\u2019d like to get some deeper integration with those tools so that people who are using those nodes have a really easy way to connect their Zap wallet and use that as their remote control. We\u2019d like to get onto looking at channel rebalancing strategies. I\u2019m not too familiar with what\u2019s going on in the space in terms of the lower level, the protocol level. I think that until we start seeing stuff at that level, maybe we can start building something on a slightly higher level to give users some tools to help them rebalance their channels. Maybe that\u2019s a manual process to start with and eventually that can fade away into the background. Then we want to look at some really cool stuff like submarine swaps, the fancy stuff\u2026 For us building on a higher level, we need some of the stuff to be more stable and built into the base protocol before we start using these types of things. We don\u2019t want to be building on new features where the API is going to change out from under us. We do want to keep integrating new cool stuff into the software.\n\n## Resources\n\nI\u2019m just going to leave you with a couple of resources that I think are really useful if you\u2019re in this space, if you\u2019re trying to keep up. The Optech newsletter is weekly, it\u2019s really awesome. It takes you about five minutes to read it. They summarize the key things that are going on in the space. They focus on Bitcoin Core, lnd, eclair and c-lightning and that sort of Bitcoin onchain, offchain crossover. They just pick out some of the key things that have gone on, some of the key developments, some of the key ideas that are coming through. You should definitely subscribe to that if you haven\u2019t already. Lnd Slack, there\u2019s like thousands of people in there talking about lnd and Lightning and asking questions, helping people out. If you\u2019re building stuff you should hang out in there. For us as we\u2019re building closely on top of lnd specifically keeping track of the GitHub milestones gives us a sense of when the next release is going to be, what\u2019s going to be in that release. We can literally see all the stories that are lined up for the next release. We can make sure that what we\u2019re building starts incorporating some of that stuff before it comes into the release and when it\u2019s in the release as well we can start pushing it out to our users. htlc.me is a really cool site. If you just want to generate an invoice and you don\u2019t have lnd running you can just go to htlc.me and you can say \u201cgive me an invoice\u201d and it will give you a Lightning invoice. You can then decode it. If you\u2019re building software on top of Lightning and you don\u2019t want to have a node running so you can get an invoice you can jump over there and it will generate you an invoice. If you want to help out with Zap or you\u2019ve got questions on Zap come and ask us in the Slack. We\u2019re in there 24/7 pretty much. Just to finish up, I would say that if I want you to take something away from this, hopefully I\u2019ve given you a sense on a slightly technical level some of the things that are involved in building out applications of Lightning. If you\u2019ve got some experience with web development or just development then you\u2019re probably qualified to start building stuff in this space. Don\u2019t be scared off by the fact that there is cryptography involved because you can come in at a higher level. You don\u2019t need to be building on the protocol. You can be building.. whether it\u2019s the device that dispenses M&Ms or a software wallet, it\u2019s really just a React Javascript web app that\u2019s making API calls. If you\u2019ve got some development experience you\u2019ve probably got what you need to start building cool stuff on Lightning.\n\n## Q&A\n\nQ - Has anyone worked on c-lightning integration for Zap?\n\nA - Not that I\u2019m aware of, I certainly haven\u2019t. I haven\u2019t seen anything. It does support Litecoin as well, some people made sure that it would work for that.\n\nQ - Is there enough abstraction in there that somebody could even do that? It sounds like there\u2019s a tight coupling with lnd.\n\nA - I\u2019m trying to abstract things out, building out mock interfaces and things like that is a step along that line. Currently we\u2019re pretty tightly coupled but there\u2019s no reason in the future that we couldn\u2019t support c-lightning.\n\nQ - There is a Zap wallet for iOS, a Zap wallet for desktop. What about a Zap wallet for Android? I hear it is almost a web app in a native container deployed to desktop systems. There are also techniques to put this into a mobile container and run this on Android.\n\nA - There are. The lnd team, Lightning Labs, are building out their wallet. I think it is called Lightning App. That is a React app as well, they\u2019re using React native so they have one app that runs in all the different environments: iOS, Android and the desktop. We took a slightly different approach with this. The iOS app is written in Swift and is a native app. There are some inherent advantages with that. We\u2019re focusing on slightly different use cases as well. WIth the desktop app we\u2019re trying to build some slightly more technical tools into it so it\u2019s not like there\u2019s a one-to-one mapping between the functionality we want to provide. In terms of Android, I don\u2019t think anyone on the Zap team uses Android so thus why it hasn\u2019t been built. If someone wants to build it. If there\u2019s enough interest we\u2019ll build it but I haven\u2019t seen that many people ask for it.\n\nQ - So if you want to support the other Lightning implementations I think that would be super useful. There\u2019s already Christian Decker\u2019s Lightning integration repo. He\u2019s already trying to support multiple nodes so he can test channels from c-lightning to lnd and vice versa and all different kinds of implementations. I think it would be so useful to have a proper API that would work against all nodes for doing all these things. All the implementations are supposed to be doing the same thing.\n\nA - That\u2019s right. Under the hood they are compatible with each other at the protocol level. When the app started to be built, lnd seemed to be one of the more popular implementations. I\u2019d say it probably still is but maybe that\u2019s just because I\u2019m in that space. As more and more people start using the different implementations it would be a shame if we\u2019re just tied to lnd and there\u2019s three other implementations and two-thirds of the user base that can\u2019t use Zap because of the particular lnd node instance they\u2019re running. Definitely something I\u2019m keen to look into. In terms of tight coupling, when we were building the BTCPay Server integration, Nicolas wanted to expose the REST API and we wanted to use the gRPC API because that\u2019s how Zap works today. It shouldn\u2019t be too hard to have an abstraction layer within Zap where you can use REST and WebSockets if you want to talk to the REST API or gRPC if you want to use that, you should be able to use both. Currently because Zap evolved out of building for a specific use case there\u2019s a tight coupling with gRPC. There\u2019s nothing in the codebase that would make it difficult to do that, the code that integrates with lnd is in a couple of specific places. There\u2019s not that much we do really. With gRPC, the gRPC gives you an object that you can natively use in Javascript. Currently it\u2019s not done right because we have our own little REST API on top of gRPC and as we communicate between the renderer process and the main process in Electron, we\u2019re basically communicating with the REST API which is then telling gRPC to do stuff. We can definitely change that and there\u2019s not too much code involved to say we could use REST and gRPC. By the same token I don\u2019t think there would be that much involved to say you can use this node implementation or that node implementation. Today it\u2019s not there.\n\nQ - I just wanted to encourage you to make it separate from Zap. Then it could be useful for testing and then you might get other contributors. You might get an interface that supports everything and not just what Zap wants to do. Win-win.\n\nA - Definitely. Everything we do is open source. A lot of it is embedded in Zap at the moment. There are a couple of libraries that we\u2019ve taken out and extracted separately. We have a library called lnd-binary which lets you really easily install lnd. You can do npm install lnd-binary. It will go to GitHub, it will fetch the lnd binary, it\u2019s got a repository of the checksums, it will validate that it\u2019s the right binary and it will extract that and make it available for use in Node. There are things like that where we\u2019re starting to pull out some of that functionality and extract it out into separate libraries. If we get to the point where we\u2019re building an abstraction or an API that can spit out to three different node implementations or however many it would definitely be something that we\u2019d open source outside of the context of Zap.\n\nfollow-up: <https://www.reddit.com/r/lightningnetwork/comments/ba3kac/tom_kirkpatrick_zap_wallet_dev_on_building_lnd/>",
    "needs_review": false,
    "indexed_at": "2024-10-22T10:48:20.362802",
    "transcript_by": "Michael Folkson",
    "domain": "https://btctranscripts.com/",
    "body_type": "markdown",
    "transcript_source": "lightning-hack-day",
    "id": "bitcointranscripts+lightning-hack-day+2018-12-01-tom-kirkpatrick-zap-wallet",
    "categories": [
        "hackathon"
    ],
    "authors": [
        "Tom Kirkpatrick"
    ],
    "summary": "Tom Kirkpatrick, a developer at Zap, has been instrumental in crafting consumer-facing applications for the Lightning Network. His work primarily focuses on the desktop wallet of Zap, aiming to streamline user interaction with the Lightning Network without requiring deep technical knowledge. The essence of Zap, as described by Kirkpatrick, lies in its simplicity and similarity across platforms, offering an accessible interface for engaging with Lightning payments.\n\nZap's foundation is a web application built using React and wrapped in Electron, making it familiar territory for those with web development experience. This structure enables seamless communication with the Lightning Network Daemon (lnd), translating user actions into network commands. Continuous integration and automated testing ensure the reliability and availability of the latest version of Zap, highlighting the team's commitment to a smooth user experience.\n\nUnderneath its user-friendly interface, Zap operates as a remote control for lnd, facilitating both local and remote connections to the Lightning Network. This dual functionality underscores the versatility of Zap, catering to diverse user preferences for managing their Lightning nodes. The integration with btcd nodes, running on the Google Cloud platform, further exemplifies Zap's robust backend infrastructure, ensuring users can connect to the Lightning Network efficiently.\n\nKirkpatrick delves into the technical intricacies of starting and managing a Lightning node through Zap, from initial setup to synchronization. The discussion extends to the challenges faced during development, including the complexities of syncing with the blockchain and the limitations of current tools for estimating transaction fees. Despite these hurdles, Zap's development team has innovated solutions, such as leveraging external APIs for fee estimation and refining the user interface to accommodate new features like fee ranges for transactions.\n\nThe introduction of storybook for Zap represents a significant leap in development efficiency, allowing the team to prototype and refine user interfaces without direct reliance on lnd. This approach not only accelerates the design process but also facilitates collaboration with non-technical stakeholders, ensuring that Zap remains intuitive and accessible.\n\nLooking ahead, Kirkpatrick outlines the roadmap for Zap, emphasizing ongoing refinements, deeper integrations with mobile wallets and hardware nodes, and exploring advanced features such as channel rebalancing and submarine swaps. The commitment to making the Lightning Network more accessible is evident through the continuous effort to enhance Zap's functionality and user experience.\n\nIn conclusion, Tom Kirkpatrick's presentation offers a comprehensive overview of Zap's development journey, underscoring the challenges and innovations in creating user-friendly Lightning Network applications. Through dedication and creativity, the Zap team is paving the way for broader adoption of Lightning, making it more accessible to a global audience."
}