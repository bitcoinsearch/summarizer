{
    "created_at": null,
    "media": "https://www.youtube.com/watch?v=u3Mn27on03A",
    "title": "ZkSHARKS",
    "body": "## Introduction\n\nIndeed I am Madars Virza. I am going to talk about SHARKs. I am going to be talking about zero-knowledge SHARKs. It's actually something serious and it's related to non-interactive zero-knowledge proofs.\n\n## Non-interactive zero knowledge proofs\n\nzkproofs are protocols between two parties, a prover and a verifier. Both prover and verifier know a public input, but only the prover knows a secret input as a witness. The prover wants to convince the verifier that some relationship holds between the public input and the secret witness. This might seem very abstract, but it's actually extremely useful.\n\nThese properties are typically formalized by completeness--- meaning that true statements have proof, and soundness--- false statements do not. Finally, there is the property of zeroknowledge. The verifier learns nothing about the secret witness beyond what is implied by the membership language. This is usually how non-interactive zero-knowledge works.\n\nBut what I have told you is a lie. There is a theorem that this is impossible for interesting languages like NP languages, without any help at least. It becomes possible if you allow yourself some kind of common reference string (CRS). There is a one-time trusted setup that outputs a reference string. This reference string can be used many times by the prover and the verifier and prove the statements respectively.\n\n## Deploying non-interactive zero-knowledge systems\n\nSo you have provers and verifiers that are geographically distributed. The question is, who generates the CRS? If it's generated maliciously, then the security properties break down. It's usually done in a cetralized setting. Maybe it's in your IT department that generates the CRS. If you want to use decentralized applications for your proof systems, then we better find out some way to generate a CRS.\n\nThe good news is that for many proof systems, the CRS is actually random. Many proof systems have a random CRS. Many things look random like sun spots, stock market, or heuristics like sha256(0) or sha256(1). So we could instantiate bulletproofs by using a CRS but we're going to get it from sha256 or something.\n\nBut there's also bad news: the most efficient proof systems have complex common reference strings that are not exactly random.\n\n## Non-interactive zero-knowledge landscape\n\nOn the one hand there's NIZKs and non-pairing-based SNARKs like bulletproofs, STARKs, Hyrax, Aurora, Spartan, etc. Then there are pairing-based SNARKs like PGHR13, Goth16, Libra, Sonic, for which the CRS is complex and it reasons about the computation template and does tests based on this. In practice, the ones without any kind of secret setup tend to have slow verification (as statement grows) and/or large proofs. Bulletproofs are really nice for small statements like rangeproofs, but if you want to prove things about a million gate circuit then verification would take like a second. But STARKs are great but they have proofs that are 100s of kilobytes.\n\nWith the computation template and complex CRS have quick verification and very small proofs in the range of 100s of bytes. Given that efficiency is desirable, maybe there's a way to get around the trusted setup.\n\n## Ideal world\n\nIn an ideal world, we would have someone trusted like maybe your IT department does it. But in a real world, we're going to have many participants each of which contributes a share to the trapdoor of the setup. Then out comes the common reference string as a result. You would want the ideal world setup and real world setups to be the same. This can actually be achieved.\n\nThe good part about this is that the constructions only require single point of success. It's not a single point of failure as in many systems, but rather we only need at least one participant to be honest and then the CRS has really been setup correctly. Collusion is probably likely to happen if certain individuals are in a room generating the setup like Putin and Trump and Snowden and Hillary or something.\n\n## Are ceremonies secure?\n\nAre these ceremonies secure? Is the trapdoor secure? I don't think anyone seriously thinks that 50 or 100 people ceremony had participants compromised or colluding. At the same time, there's an epistemological question like why should I believe that those 100 participants even existed? Do I know? In a hundred years, it becomes a myth. Did it really happen? Do I know anyone who participated? In 100 years, will anyone remember the prominent cryptographers from 2019? Maybe I should accept slower verification, or lower efficiency? Does it matter?\n\nThere are scenarios where efficiency does matter. Sometimes the propagation speed and verification speed do matter. The propagation speed is dependent on how fast they can verify the transactions. There are also other participants in the system like miners or block producers. They need to get transactions fast and include them in blocks. Even more so, you need to verify the previous block to decide what to mine on top of. So verification is a security risk, there are incidents where people were doing SPV mining and they figured signature verification was too expensive so they turned it off or something. Ideally we would like miners to not do that.\n\n## zkSHARK: zero-knowledge succinct hybrid argument of knowledge\n\nzkSHARKs have short proofs that can be verified in one of two ways. There's prudent verification which is asymptotically slow, comparable to bulletproofs, but do not require any kind of trusted setup. Then there's optimistic verification which is fast (comparable to pairing-based SNARKs), but it relies on a trusted setup ceremony. During transaction propagation, the idea is to optimistically verify the transactions. Miners would then do prudent verification. They would verify provisionally using the optimistic mode, and then later before proof-of-work they do the slow verification.\n\n## What happens if prudent verification fails?\n\nWhat happens if optimistic verification passes, but prudent verification fails? This can be detected in real-time. You can immediately see that this pair of transactions, where the prudent proof didn't verify but the optimistic one did, is a fraud proof. This is irrefutable proof that something fishy is going on with the setup. Once you see this, you revoke the setup parameters. In zkSHARKs, you can recover soundness by prudently verifying and then you recover efficiency by redoing the setup. The good part about zkSHARKs is that the optimistic proofs can be generated by anyone without the original sender or original witness. In 100 years, we might not remember who the greatest cryptographers of our era, but maybe their new guys can be the participants of this system, and they would be able to refresh all the old proofs.\n\n## A (broken) generic SHARK construction\n\nSomeone might think, well, isn't this the same as concatenating in parallel an existing proof system without setup like bulletproofs and a typical snark like Groth16? Well let's see. Say this is a standard proof system where someone produces a proof and someone verifies it. I am going to construct a snark for a fixed language and construct a NIZK for that fixed language. Maybe this SNARK proof can serve as my optimistic proof, but it can't. Optimistic proofs should be refreshable without knowing the witness. Those proofs, if I want to refresh them, then I necessarily need to know the witness to run the SNARK prover. So SHARK is not just two proofs yanked together side by side.\n\n## A generic SHARK construction\n\nSay I have a fixed language... then I construct a SNARK for the langauge that the NIZK verifier proving that the NIZK verifier was satisfied. My SNARK proof reasons about NIZK verification and it doesn't need to know the witness because my NIZK verifier doesn't need to know the witness. So if you give me any two proof systems one with trusted setup and one without, then you can get a SHARK.\n\nThat's nice, but it's not too excited from an efficiency perspective. You could do it, but it is going to be challenging to get an efficient SHARK out of it. But say I took bulletproofs and a NIZK and Groth16 SNARKs. Well, my prover starts by reasoning about a circuit of some size. Bulletproofs prover, well, it does some operations and the bulletproofs verifier actually does security parameter times the security circuit size group operations and then it needs to embed this bulletproof verifier. While we get some speedup with mod exponentiation and what not, your SNARK verifier is going to take up ... and if your security parameter is 256, then the constants are pretty accurate here, it's likely not going to be efficient.\n\n## Efficient SHARK construct\n\nWe can get a lean SHARK by working directly. We first start by making a NIZK for R1CS which is basically a language for arithmetic circuits with bilinear gates. We do this by presenting a new technique for linear PCPs (LPCPs) in a prudent mode proof system for a public coin NIZK. In order to do this, we also produce an optimized variant of bulletproofs inner product argument. Our proof system is tailored so that-- it has an \"algebraic heart\" so we don't need to do generic embedding into a SNARK prover, instead we can construct a special SNARK that only knows how to make statements about our NIZK verifier. It's a special-purpose SNARK, and we introduce encoded polynomial delegation to achieve a special purpose SNARK and avoid the lambda squared blow-up in the construction. And that's our SHARK.\n\nWhile you're waiting for the eprint, you can watch this other talk with more details.\n\n<https://youtube.com/watch?v=OP8ydUxAVt4>",
    "url": "https://btctranscripts.com/cryptoeconomic-systems/2019/zksharks",
    "tags": [
        "proof-systems"
    ],
    "body_formatted": "## Introduction\n\nIndeed I am Madars Virza. I am going to talk about SHARKs. I am going to be talking about zero-knowledge SHARKs. It's actually something serious and it's related to non-interactive zero-knowledge proofs.\n\n## Non-interactive zero knowledge proofs\n\nzkproofs are protocols between two parties, a prover and a verifier. Both prover and verifier know a public input, but only the prover knows a secret input as a witness. The prover wants to convince the verifier that some relationship holds between the public input and the secret witness. This might seem very abstract, but it's actually extremely useful.\n\nThese properties are typically formalized by completeness--- meaning that true statements have proof, and soundness--- false statements do not. Finally, there is the property of zeroknowledge. The verifier learns nothing about the secret witness beyond what is implied by the membership language. This is usually how non-interactive zero-knowledge works.\n\nBut what I have told you is a lie. There is a theorem that this is impossible for interesting languages like NP languages, without any help at least. It becomes possible if you allow yourself some kind of common reference string (CRS). There is a one-time trusted setup that outputs a reference string. This reference string can be used many times by the prover and the verifier and prove the statements respectively.\n\n## Deploying non-interactive zero-knowledge systems\n\nSo you have provers and verifiers that are geographically distributed. The question is, who generates the CRS? If it's generated maliciously, then the security properties break down. It's usually done in a cetralized setting. Maybe it's in your IT department that generates the CRS. If you want to use decentralized applications for your proof systems, then we better find out some way to generate a CRS.\n\nThe good news is that for many proof systems, the CRS is actually random. Many proof systems have a random CRS. Many things look random like sun spots, stock market, or heuristics like sha256(0) or sha256(1). So we could instantiate bulletproofs by using a CRS but we're going to get it from sha256 or something.\n\nBut there's also bad news: the most efficient proof systems have complex common reference strings that are not exactly random.\n\n## Non-interactive zero-knowledge landscape\n\nOn the one hand there's NIZKs and non-pairing-based SNARKs like bulletproofs, STARKs, Hyrax, Aurora, Spartan, etc. Then there are pairing-based SNARKs like PGHR13, Goth16, Libra, Sonic, for which the CRS is complex and it reasons about the computation template and does tests based on this. In practice, the ones without any kind of secret setup tend to have slow verification (as statement grows) and/or large proofs. Bulletproofs are really nice for small statements like rangeproofs, but if you want to prove things about a million gate circuit then verification would take like a second. But STARKs are great but they have proofs that are 100s of kilobytes.\n\nWith the computation template and complex CRS have quick verification and very small proofs in the range of 100s of bytes. Given that efficiency is desirable, maybe there's a way to get around the trusted setup.\n\n## Ideal world\n\nIn an ideal world, we would have someone trusted like maybe your IT department does it. But in a real world, we're going to have many participants each of which contributes a share to the trapdoor of the setup. Then out comes the common reference string as a result. You would want the ideal world setup and real world setups to be the same. This can actually be achieved.\n\nThe good part about this is that the constructions only require single point of success. It's not a single point of failure as in many systems, but rather we only need at least one participant to be honest and then the CRS has really been setup correctly. Collusion is probably likely to happen if certain individuals are in a room generating the setup like Putin and Trump and Snowden and Hillary or something.\n\n## Are ceremonies secure?\n\nAre these ceremonies secure? Is the trapdoor secure? I don't think anyone seriously thinks that 50 or 100 people ceremony had participants compromised or colluding. At the same time, there's an epistemological question like why should I believe that those 100 participants even existed? Do I know? In a hundred years, it becomes a myth. Did it really happen? Do I know anyone who participated? In 100 years, will anyone remember the prominent cryptographers from 2019? Maybe I should accept slower verification, or lower efficiency? Does it matter?\n\nThere are scenarios where efficiency does matter. Sometimes the propagation speed and verification speed do matter. The propagation speed is dependent on how fast they can verify the transactions. There are also other participants in the system like miners or block producers. They need to get transactions fast and include them in blocks. Even more so, you need to verify the previous block to decide what to mine on top of. So verification is a security risk, there are incidents where people were doing SPV mining and they figured signature verification was too expensive so they turned it off or something. Ideally we would like miners to not do that.\n\n## zkSHARK: zero-knowledge succinct hybrid argument of knowledge\n\nzkSHARKs have short proofs that can be verified in one of two ways. There's prudent verification which is asymptotically slow, comparable to bulletproofs, but do not require any kind of trusted setup. Then there's optimistic verification which is fast (comparable to pairing-based SNARKs), but it relies on a trusted setup ceremony. During transaction propagation, the idea is to optimistically verify the transactions. Miners would then do prudent verification. They would verify provisionally using the optimistic mode, and then later before proof-of-work they do the slow verification.\n\n## What happens if prudent verification fails?\n\nWhat happens if optimistic verification passes, but prudent verification fails? This can be detected in real-time. You can immediately see that this pair of transactions, where the prudent proof didn't verify but the optimistic one did, is a fraud proof. This is irrefutable proof that something fishy is going on with the setup. Once you see this, you revoke the setup parameters. In zkSHARKs, you can recover soundness by prudently verifying and then you recover efficiency by redoing the setup. The good part about zkSHARKs is that the optimistic proofs can be generated by anyone without the original sender or original witness. In 100 years, we might not remember who the greatest cryptographers of our era, but maybe their new guys can be the participants of this system, and they would be able to refresh all the old proofs.\n\n## A (broken) generic SHARK construction\n\nSomeone might think, well, isn't this the same as concatenating in parallel an existing proof system without setup like bulletproofs and a typical snark like Groth16? Well let's see. Say this is a standard proof system where someone produces a proof and someone verifies it. I am going to construct a snark for a fixed language and construct a NIZK for that fixed language. Maybe this SNARK proof can serve as my optimistic proof, but it can't. Optimistic proofs should be refreshable without knowing the witness. Those proofs, if I want to refresh them, then I necessarily need to know the witness to run the SNARK prover. So SHARK is not just two proofs yanked together side by side.\n\n## A generic SHARK construction\n\nSay I have a fixed language... then I construct a SNARK for the langauge that the NIZK verifier proving that the NIZK verifier was satisfied. My SNARK proof reasons about NIZK verification and it doesn't need to know the witness because my NIZK verifier doesn't need to know the witness. So if you give me any two proof systems one with trusted setup and one without, then you can get a SHARK.\n\nThat's nice, but it's not too excited from an efficiency perspective. You could do it, but it is going to be challenging to get an efficient SHARK out of it. But say I took bulletproofs and a NIZK and Groth16 SNARKs. Well, my prover starts by reasoning about a circuit of some size. Bulletproofs prover, well, it does some operations and the bulletproofs verifier actually does security parameter times the security circuit size group operations and then it needs to embed this bulletproof verifier. While we get some speedup with mod exponentiation and what not, your SNARK verifier is going to take up ... and if your security parameter is 256, then the constants are pretty accurate here, it's likely not going to be efficient.\n\n## Efficient SHARK construct\n\nWe can get a lean SHARK by working directly. We first start by making a NIZK for R1CS which is basically a language for arithmetic circuits with bilinear gates. We do this by presenting a new technique for linear PCPs (LPCPs) in a prudent mode proof system for a public coin NIZK. In order to do this, we also produce an optimized variant of bulletproofs inner product argument. Our proof system is tailored so that-- it has an \"algebraic heart\" so we don't need to do generic embedding into a SNARK prover, instead we can construct a special SNARK that only knows how to make statements about our NIZK verifier. It's a special-purpose SNARK, and we introduce encoded polynomial delegation to achieve a special purpose SNARK and avoid the lambda squared blow-up in the construction. And that's our SHARK.\n\nWhile you're waiting for the eprint, you can watch this other talk with more details.\n\n<https://youtube.com/watch?v=OP8ydUxAVt4>",
    "needs_review": false,
    "indexed_at": "2024-10-22T10:48:20.386711",
    "transcript_by": "Bryan Bishop",
    "domain": "https://btctranscripts.com/",
    "body_type": "markdown",
    "transcript_source": "cryptoeconomic-systems",
    "id": "bitcointranscripts+cryptoeconomic-systems+2019+zksharks",
    "categories": [
        "conference"
    ],
    "authors": [
        "Madars Virza"
    ],
    "summary": "In a recent discussion, Madars Virza introduced an innovative concept within the realm of cryptography: zero-knowledge SHARKs (zkSHARKs), which form part of non-interactive zero-knowledge proofs. These protocols facilitate a way for a prover to assure a verifier of the truthfulness of a statement without revealing any additional information beyond what the proof itself conveys. This mechanism is not only foundational to maintaining privacy but also to enabling secure verification in cryptographic systems.\n\nThe core challenge with implementing non-interactive zero-knowledge proofs lies in the necessity of a common reference string (CRS), which is vital for the integrity of the proof system. The generation of this CRS, particularly in a decentralized context, poses a significant security risk if not handled correctly. Virza points out that while some proof systems can rely on seemingly random sources for their CRS, the most efficient systems require a more complex setup, which isn't inherently random and thus demands a carefully constructed CRS to ensure security.\n\nExploring the landscape of non-interactive zero-knowledge proofs, Virza distinguishes between NIZKs and various SNARKs, noting the trade-offs between systems that require a trusted setup and those that do not. Efficiency becomes a critical factor, especially in applications where verification speed is paramount. However, the reliance on a trusted setup, necessary for pairing-based SNARKs to achieve their efficiency, introduces potential vulnerabilities and centralization concerns.\n\nVirza proposes an ideal scenario where the generation of the CRS could be distributed among multiple participants, ensuring that as long as one participant is honest, the system remains secure. This method highlights a shift from viewing the setup process as a potential single point of failure to a single point of success, drastically reducing the likelihood of collusion and increasing the overall trustworthiness of the system.\n\nAddressing the practicality and security of such \"ceremonies\" for generating the CRS, Virza acknowledges the skepticism surrounding their long-term reliability and transparency. He suggests that while trusting these setups might be challenging, the efficiency gains in certain contexts, where quick transaction verification is crucial, cannot be overlooked.\n\nIntroducing zkSHARKs as a solution, Virza outlines how they offer dual modes of verification: a slower, more secure mode without the need for a trusted setup, and a faster, optimistic mode that does. This hybrid approach allows for flexibility in transaction verification, catering to both security and efficiency needs. Moreover, in the event of a discrepancy between the two verification modes, the system provides mechanisms for real-time detection and rectification, ensuring the integrity of the proof system.\n\nVirza further elaborates on the construction of zkSHARKs, emphasizing the importance of creating a system that can efficiently handle arithmetic circuits through a new technique involving linear PCPs and an optimized variant of bulletproofs. This approach allows for the creation of a specialized SNARK that is both efficient and tailored to the specifics of the zkSHARK system, avoiding the inefficiencies that would arise from combining general-purpose proof systems.\n\nMadars Virza's contribution to the field through the development of zkSHARKs represents a significant step forward in addressing the challenges associated with non-interactive zero-knowledge proofs. By balancing the demands for privacy, security, and efficiency, zkSHARKs pave the way for more robust cryptographic systems capable of supporting a wide range of applications, from blockchain technology to secure communications."
}