<?xml version="1.0" ?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <id>2</id>
  <title>Combined summary - An explanation and justification of the tail-call and MBV approach to MAST</title>
  <updated>2025-09-26T15:48:58.819631+00:00</updated>
  <generator uri="https://lkiesow.github.io/python-feedgen" version="0.9.0">python-feedgen</generator>
  <thread>
    <message id="msg_1" depth="0" position="0" anchor="m3128f5edef9e43b8b405ee5639b673c34c483c01">
      <author>[bitcoin-dev] An explanation and justification of the tail-call and MBV approach to MAST Mark Friedenbach</author>
      <timestamp>2017-09-20T22:51:00.000Z</timestamp>
    </message>
    <message id="msg_2" depth="1" position="1" reply_to="[bitcoin-dev] An explanation and justification of the tail-call and MBV approach to MAST Mark Friedenbach" parent_id="mailing-list-2017-09-m3128f5edef9e43b8b405ee5639b673c34c483c01" anchor="m3c5363ddaa3d12d9e0e20a333d213d7a0ab72050">
      <author>Andreas M. Antonopoulos</author>
      <timestamp>2017-09-21T00:15:00.000Z</timestamp>
    </message>
  </thread>
  <link href="bitcoin-dev/Sept_2017/015029_An-explanation-and-justification-of-the-tail-call-and-MBV-approach-to-MAST.xml" rel="alternate"/>
  <link href="bitcoin-dev/Sept_2017/015028_An-explanation-and-justification-of-the-tail-call-and-MBV-approach-to-MAST.xml" rel="alternate"/>
  <link href="https://gnusha.org/url/https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2017-September/015028.html" rel="alternate"/>
  <entry>
    <id>2</id>
    <title>Combined summary - An explanation and justification of the tail-call and MBV approach to MAST</title>
    <updated>2025-09-26T15:48:58.820053+00:00</updated>
    <link href="https://gnusha.org/url/https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2017-September/015028.html" rel="alternate"/>
    <published>2017-09-21T00:15:37+00:00</published>
    <summary>In this article, the use of Merklized Abstract Syntax Trees (MAST) in Bitcoin is explored. The author begins by discussing the execution of Pay-to-Script Hash (P2SH) and how it can be generalized beyond a single redeem script. The concept of implicit tail-call execution semantics is introduced, allowing for safe recursion by running scripts to the end. The article explains how this approach can be used to achieve MAST and how the MERKLEBRANCHVERIFY opcode simplifies the process.The MERKLEBRANCHVERIFY opcode is used to prove that a public key is part of a set used to construct a Merkle hash tree and checks its signature. This enables verification of any monotone Boolean function over combinations of public keys, making it applicable to various use cases. The author emphasizes the importance of permission-less innovation in Bitcoin consensus features and suggests using modularity and composition of simple yet powerful tools like MERKLEBRANCHVERIFY and single tail-call recursion to construct MAST with minimal changes to the consensus code.The article concludes by mentioning the efficiency gain of adopting a MAST template but recommends deploying MBV, tail-call, and overhauling the CHECKSIG operator before tackling an ideal MAST-supporting witness type. The author highlights the clear explanation provided on the MERKLEBRANCHVERIFY opcode and tail-call execution semantics, which are crucial for achieving MAST in Bitcoin.In recent weeks, developers have been educated on the MERKLEBRANCHVERIFY opcode and tail-call execution semantics, but there are concerns about the clarity of concepts presented in the Bitcoin Improvement Proposals (BIPs). The limitations of P2SH are discussed, and macro-op fusion is introduced as a way to generalize it. The article also touches on MAST with tail-call alone or general recursion.The author supports permission-less innovation and advocates for simplicity, modularity, and the ability of different tools to work together in Bitcoin consensus features. They propose that the primitives of tail-call and MAST enable complex features with minimal changes to the consensus code, allowing for unrestricted innovation. These primitives can be combined with other modular features to support various use cases beyond vanilla MAST.The article mentions multiple potential use cases for the proposed features, including honeypot bounties, split proofs, Wuille-Maxwell tree signatures, delegation, signature-time commitment, and reusable Lamport keys. The author argues against rigid templates that require workarounds for each future innovation and instead supports small, modular, incremental, and reusable changes that create a platform for innovation.Overall, the article provides a comprehensive explanation of the MERKLEBRANCHVERIFY opcode and tail-call execution semantics, highlighting their importance in achieving MAST in Bitcoin. It emphasizes the need for permission-less innovation and proposes the use of simple yet powerful tools to construct MAST while minimizing changes to the consensus code.</summary>
  </entry>
</feed>