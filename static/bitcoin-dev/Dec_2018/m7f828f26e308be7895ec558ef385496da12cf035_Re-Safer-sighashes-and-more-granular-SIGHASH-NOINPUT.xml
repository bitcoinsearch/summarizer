<?xml version='1.0' encoding='UTF-8'?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <id>1</id>
  <title>Re: Safer sighashes and more granular SIGHASH_NOINPUT</title>
  <updated>2025-11-12T03:49:25.881872+00:00</updated>
  <author>
    <name>Johnson Lau 2018-12-17 19:08:00+00:00</name>
  </author>
  <generator uri="https://lkiesow.github.io/python-feedgen" version="0.9.0">python-feedgen</generator>
  <entry>
    <id>1</id>
    <title>Re: Safer sighashes and more granular SIGHASH_NOINPUT</title>
    <updated>2025-11-12T03:49:25.881904+00:00</updated>
    <link href="https://gnusha.org/pi/bitcoindev/20181128140412.GC22873@mcelrath.org/T/#m7f828f26e308be7895ec558ef385496da12cf035" rel="alternate"/>
    <summary>The discourse highlights the nuanced debate around security measures in cryptocurrency, specifically within the Bitcoin protocol. The initial argument posits that all effective security measures may seem excessive until a failure occurs, emphasizing the importance of preemptive security to protect against potential vulnerabilities. This discussion leads into the specific issue of private key reuse in the Bitcoin network. There are primarily two ways through which funds can be lost due to private key reuse: reusing the same signature nonce and signing with the hash "one" because of the SIGHASH_SINGLE consensus bug. The latter has been addressed in SegWit, albeit not completely eradicated, and could be further mitigated through a simple soft fork.

Private key reuse, while detrimental to fungibility and privacy, is not considered highly insecure provided certain precautions are taken, such as adherence to rfc6979 and avoiding the signature of hash "one". This security is partly thanks to how signatures commit to the previous transaction ID, ensuring a signature cannot validate more than one UTXO. However, this mechanism also incentivized the practice of key reuse from Bitcoin's inception. The introduction of NOINPUT alters the security assumptions by enabling new vectors for fund loss through key reuse, sparking debate on its implications for long-standing practices within the Bitcoin community.

The conversation also touches upon the challenges faced by wallet developers in replicating consensus code. The advice given is to implement only the necessary features while avoiding extraneous details that could introduce vulnerabilities, such as being tricked into signing a compromised hash. For instance, the necessity of implementing OP_CODESEPARATOR is questioned if not directly used, suggesting a minimalist approach to feature inclusion in wallets. 

In relation to signature schemes like BIP143 where signatures commit to the script being executed, it's suggested that wallets could simplify their operations by focusing on supported script templates rather than attempting to parse every possible script scenario. This would minimize complexity and potential security risks, especially concerning features like NOINPUT that might not be universally required or beneficial.

Lastly, the dialogue underscores a broader principle guiding Bitcoin protocol development: the trade-off between security, complexity, and functionality. Security often takes precedence, influencing the cautious stance of core contributors towards proposals like BIP148 despite the potential benefits of implemented features such as SegWit. The debate over NOINPUT exemplifies the complexities involved in evolving the Bitcoin protocol, where the introduction of new features must be carefully weighed against the perpetual support they require and the irreversible changes they make to the network's security landscape.</summary>
    <published>2018-12-17T19:08:00+00:00</published>
  </entry>
</feed>
