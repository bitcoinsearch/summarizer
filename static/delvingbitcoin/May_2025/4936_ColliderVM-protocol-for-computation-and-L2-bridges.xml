<?xml version='1.0' encoding='UTF-8'?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <id>0</id>
  <title>ColliderVM protocol for computation and L2 bridges</title>
  <updated>2025-05-05T02:47:46.155792+00:00</updated>
  <author>
    <name>victorkstarkware 2025-05-04 12:08:34.491000+00:00</name>
  </author>
  <generator uri="https://lkiesow.github.io/python-feedgen" version="0.9.0">python-feedgen</generator>
  <entry>
    <id>0</id>
    <title>ColliderVM protocol for computation and L2 bridges</title>
    <updated>2025-05-05T02:47:46.155822+00:00</updated>
    <link href="https://delvingbitcoin.org/t/collidervm-protocol-for-computation-and-l2-bridges/1662" rel="alternate"/>
    <summary>ColliderVM is an innovative protocol designed to facilitate stateful computation on the Bitcoin network, expanding its capabilities beyond what's currently possible with native Bitcoin script alone. Unlike BitVM, ColliderVM operates without the need for fraud proofs, thereby eliminating the associated fraud-proof time window. This characteristic significantly simplifies the underlying trust model and operational requirements, making it an attractive alternative for applications requiring logic and data persistence across multiple transactions.

Stateful computation within ColliderVM is divided into two main components: logic persistence and data persistence. Logic persistence ensures that Bitcoin locking scripts are executed in a predefined order, enabling a sequence of transactions to follow a logical flow. Data persistence, on the other hand, allows for the passing of information between these transactions. This feature is crucial for supporting complex operations and interactions that span multiple blockchain entries, facilitating a richer set of functionalities such as smart contracts and bridge designs to layer two networks.

The motivation behind developing stateful computation on Bitcoin stems from the desire to overcome the limitations imposed by Bitcoin's current script size and stack element constraints. Such enhancements are deemed necessary for supporting long computations and computations invoked at multiple points in time. These improvements could significantly enhance Bitcoin's utility by enabling smart contracts and seamless bridges to layer two networks, thereby increasing its scalability, functionality, and privacy.

Common approaches to achieving stateful computation on Bitcoin include using multisig arrangements, strong covenants, or protocols like BitVM. Each method comes with its trade-offs in terms of security, decentralization, and practicality. ColliderVM proposes a novel approach by employing presigned transaction templates for logic persistence and a hash collision-based mechanism for data persistence, drawing inspiration from ColliderScript.

ColliderVM distinguishes itself through several notable advantages, including capital efficiency, reduced operator burden during deposits, and simplified transaction flows. However, it also faces challenges related to its overall cost, primarily due to the on-chain presence of all computations and the need for efficient hash function implementations within the Bitcoin scripting environment. Furthermore, the protocol requires operators to manage a moderate volume of signatures and perform a significant amount of hash evaluations for withdrawal processes.

Looking forward, there is considerable potential for optimizing ColliderVM and extending its applicability within the Bitcoin ecosystem. Future research directions include exploring more Bitcoin-friendly hash functions, enhancing STARK verifier implementations, reducing the workload for signers, minimizing data storage requirements, and widening the computational gap between honest and malicious operators. For more detailed insights into ColliderVM, interested readers can refer to the published paper [here](https://eprint.iacr.org/2025/591) and watch an explanatory video [here](https://starkware.co/blog/avihu-levy-bitcoin-horizons-from-op_cat-to-covenants-hong-kong/).</summary>
    <published>2025-05-04T12:08:34.491000+00:00</published>
  </entry>
</feed>
