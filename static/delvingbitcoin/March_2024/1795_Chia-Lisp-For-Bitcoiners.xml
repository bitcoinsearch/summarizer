<?xml version='1.0' encoding='UTF-8'?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <id>1</id>
  <title>Chia Lisp For Bitcoiners</title>
  <updated>2024-03-06T01:51:45.988936+00:00</updated>
  <author>
    <name>ProofOfKeags</name>
  </author>
  <timestamp>2024-03-05T21:08:41.406000+00:00</timestamp>
  <generator uri="https://lkiesow.github.io/python-feedgen" version="0.9.0">python-feedgen</generator>
  <entry>
    <id>1</id>
    <title>Chia Lisp For Bitcoiners</title>
    <updated>2024-03-06T01:51:45.988963+00:00</updated>
    <link href="https://delvingbitcoin.org/t/chia-lisp-for-bitcoiners/636/5" rel="alternate"/>
    <summary>The discussion highlights the potential of integrating Simplicity with state-of-the-art (SOTA) proof assistants, drawing parallels to programming languages like Idris and Agda that utilize Chez Scheme for code generation. Scheme, known for its clean and lean approach compared to LISP, suggests an avenue for simplicity without the necessity of formal verification of output, though such a feature remains desirable. The process of compiling often involves a trade-off where structural information is lost, which poses a challenge in preserving the integrity and desired properties of the original source code during translation to the target language. This target language, crucially viewed through the lens of consensus virtual machines (VMs), benefits from formal verification as it ensures properties are maintained irrespective of the source language.

However, the preservation of structural information comes with its own set of challenges, notably the increased space requirements and the potential computational cost during transaction validation. An alternative approach proposes conducting formal verification at the source level, ensuring the transformation to the target language maintains certain key properties. This method significantly reduces network validation costs but risks cementing the source language as a standard, introducing new limitations. 

The conversation also entertains the idea of adopting a LISP-like target language for research purposes. Such a language would offer flexibility similar to Simplicity but without the extensive need for verifying computations down to the foundational mathematical principles of distributive categories. This perspective opens up discussions on balancing between efficiency, formal verification, and the practicality of programming language design within the realm of consensus computing and transaction validation.</summary>
    <published>2024-03-05T21:08:41.406000+00:00</published>
  </entry>
</feed>
