<?xml version='1.0' encoding='UTF-8'?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <id>1</id>
  <title>Exploring Extended Relative Timelocks</title>
  <updated>2025-07-17T03:00:20.866269+00:00</updated>
  <author>
    <name>pyth</name>
  </author>
  <timestamp>2025-07-16T09:27:16.850000+00:00</timestamp>
  <generator uri="https://lkiesow.github.io/python-feedgen" version="0.9.0">python-feedgen</generator>
  <entry>
    <id>1</id>
    <title>Exploring Extended Relative Timelocks</title>
    <updated>2025-07-17T03:00:20.866317+00:00</updated>
    <link href="https://delvingbitcoin.org/t/exploring-extended-relative-timelocks/1818/12" rel="alternate"/>
    <summary>The process of managing Bitcoin transactions involves a technique known as refreshing the relative lock. This method allows users to transfer their funds to a different wallet, where they can then reset the nLockTime value. A specific application that utilizes this mechanism is BitcoinKeeper. However, employing this strategy comes with certain challenges. Each time the timelock is refreshed or "rolled," it necessitates the creation of a new descriptor. The implications of this requirement are twofold. Firstly, there is an essential need to create a comprehensive backup of the new descriptor. This step is crucial for maintaining access to and control over the funds associated with that descriptor. Secondly, it becomes necessary to register and validate the updated policy on all signing devices involved in the transaction process. Without completing these steps, the integrity and security of the transaction could be compromised, highlighting the importance of thoroughness in managing these procedures.</summary>
    <published>2025-07-16T09:27:16.850000+00:00</published>
  </entry>
</feed>
