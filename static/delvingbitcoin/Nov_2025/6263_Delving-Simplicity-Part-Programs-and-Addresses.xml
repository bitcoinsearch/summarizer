<?xml version='1.0' encoding='UTF-8'?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <id>0</id>
  <title>Delving Simplicity Part ‚Ö§: Programs and Addresses</title>
  <updated>2025-11-18T02:47:26.345471+00:00</updated>
  <author>
    <name>roconnor-blockstream 2025-11-17 20:32:26.776000+00:00</name>
  </author>
  <generator uri="https://lkiesow.github.io/python-feedgen" version="0.9.0">python-feedgen</generator>
  <entry>
    <id>0</id>
    <title>Delving Simplicity Part ‚Ö§: Programs and Addresses</title>
    <updated>2025-11-18T02:47:26.345502+00:00</updated>
    <link href="https://delvingbitcoin.org/t/delving-simplicity-part-programs-and-addresses/2113" rel="alternate"/>
    <summary>In the latest installment of our series on Simplicity, a blockchain programming language designed for Bitcoin and Liquid applications, we delve into the intricacies of how Simplicity expressions can influence transactions. Specifically, we examine the Reader and Failure effects that play pivotal roles in transaction validation. A Simplicity program is defined as an expression from `ùüô` to `ùüô`, leveraging these effects to provide read-only access to transaction data and to determine transaction success or failure, respectively. Unlike traditional inputs and outputs, Simplicity types are integral to the internal composition of subexpressions within a program, ensuring its sound execution.

The storage of Simplicity programs in transaction outputs has evolved from the Pay-to-Script-Hash (P2SH) method used by Bitcoin to employing a commitment Merkle root (CMR). This approach not only facilitates a uniform addressing scheme irrespective of the program's complexity but also leverages SHA-256 hashing for secure and efficient storage. Tags associated with each Simplicity combinator are hashed to construct a unique 256-bit CMR. This CMR then serves as the basis for the program's address, using a process that involves the Taproot mechanism outlined in [BIP-0341](https://github.com/bitcoin/bips/blob/bbaea3182b258a4eadc100279ec71c7a4a30482e/bip-0341.mediawiki) and further hashing techniques detailed in [BIP-0340](https://github.com/bitcoin/bips/blob/bbaea3182b258a4eadc100279ec71c7a4a30482e/bip-0340.mediawiki).

To illustrate the process, we use the simplest possible Simplicity program, `unit : ùüô ‚ä¢ ùüô`, which effectively acts as a no-op but succeeds in all cases. The construction of an address for this program involves calculating its CMR, deriving a TapLeaf tagged hash, and tweaking an internal public key according to specifications in BIP-0341. The final address is expressed in the Bech32 format, following procedures from BIP-0173 and BIP-0350.

Additionally, we introduce witness expressions, a novel kind of Simplicity expression designed to incorporate signature data and other witness information directly into a transaction. Unlike conventional expressions, witness expressions solely carry values and exclude these from the program‚Äôs CMR, enabling dynamic insertion at redemption time. This flexibility supports more efficient program execution and simplifies the inclusion of digital signatures or other authentication measures.

This exploration of Simplicity's foundational elements, including the commitment Merkle root, address generation, and the utilization of witness expressions, underscores the language's potential to enhance security, efficiency, and flexibility in blockchain programming. The forthcoming discussion on jets will further detail mechanisms to streamline and optimize Simplicity programs, particularly focusing on single-signature verification processes.</summary>
    <published>2025-11-17T20:32:26.776000+00:00</published>
  </entry>
</feed>
